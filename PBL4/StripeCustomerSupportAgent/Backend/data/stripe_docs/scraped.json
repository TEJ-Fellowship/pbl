[
  {
    "id": "api_1759821323083",
    "url": "https://stripe.com/docs/api",
    "category": "api",
    "title": "",
    "content": "# API Reference The Stripe API is organized around [REST](http://en.wikipedia.org/wiki/Representational_State_Transfer). Our API has predictable resource-oriented URLs, accepts [form-encoded](https://en.wikipedia.org/wiki/POST_\\(HTTP\\)#Use_for_submitting_web_forms) request bodies, returns [JSON-encoded](http://www.json.org/) responses, and uses standard HTTP response codes, authentication, and verbs. You can use the Stripe API in test mode, which doesn’t affect your live data or interact with the banking networks. The API key you use to [authenticate](https://docs.stripe.com/api/authentication.md) the request determines whether the request is live mode or test mode. The Stripe API doesn’t support bulk updates. You can work on only one object per request. The Stripe API differs for every account as we release new [versions](https://docs.stripe.com/api/versioning.md) and tailor functionality. Log in to see docs with your test key and data. ## Just getting started? Check out our [development quickstart](https://docs.stripe.com/development/quickstart.md) guide. ## Not a developer? Use Stripe’s [no-code options](https://docs.stripe.com/payments/no-code.md) or apps from [our partners](https://stripe.partners/) to get started with Stripe and to do more with your Stripe account—no code required. ### Base URL ```plaintext https://api.stripe.com ```",
    "wordCount": 158,
    "scrapedAt": "2025-10-07T07:15:23.083Z",
    "docType": "api",
    "metadata": {
      "source": "stripe.com",
      "contentType": "text/plain; charset=utf-8"
    }
  },
  {
    "id": "webhooks_1759821325016",
    "url": "https://stripe.com/docs/webhooks",
    "category": "webhooks",
    "title": "",
    "content": "# Receive Stripe events in your webhook endpoint Listen for events in your Stripe account on your webhook endpoint so your integration can automatically trigger reactions. > #### Send events to your AWS account > > You can now send events directly to [Amazon EventBridge as an event destination](https://docs.stripe.com/event-destinations/eventbridge.md). Create an event destination to receive events at an HTTPS webhook endpoint. After you register a webhook endpoint, Stripe can push real-time event data to your application’s webhook endpoint when [events](https://docs.stripe.com/event-destinations.md#events-overview) happen in your Stripe account. Stripe uses HTTPS to send webhook events to your app as a JSON payload that includes an [Event object](https://docs.stripe.com/api/events.md). Receiving webhook events helps you respond to asynchronous events, such as when a customer’s bank confirms a payment, a customer disputes a charge, or a recurring payment succeeds. ## Get started To start receiving webhook events in your app: 1. Create a webhook endpoint handler to receive event data POST requests. 1. Test your webhook endpoint handler locally using the Stripe CLI. 1. Create a new [event destination](https://docs.stripe.com/event-destinations.md) for your webhook endpoint. 1. Secure your webhook endpoint. You can register and create one endpoint to handle several different event types at the same time, or set up individual endpoints for specific events. ## Unsupported event type behaviors for organization event destinations Stripe sends most event types asynchronously, but waits for a response for some event types. In these cases, Stripe behaves differently based on whether or not the event destination responds. If your event destination receives [Organization](https://docs.stripe.com/get-started/account/orgs.md) events, those requiring a response have the following limitations: - You can’t subscribe to `issuing_authorization.request` for organization destinations. Instead, set up a [webhook endpoint](https://docs.stripe.com/webhooks.md#example-endpoint) in a Stripe account within the organization to subscribe to this event type. Use `issuing_authorization.request` to authorize purchase requests in real-time. - Organization destinations receiving `checkout_sessions.completed` can’t [handle redirect behavior](https://docs.stripe.com/checkout/fulfillment.md#redirect-hosted-checkout) when you embed [Checkout](https://docs.stripe.com/payments/checkout.md) directly in your website or redirect customers to a Stripe-hosted payment page. To influence Checkout redirect behavior, process this event type with a [webhook endpoint](https://docs.stripe.com/webhooks.md#example-endpoint) configured in a Stripe account within the organization. - Organization destinations responding unsuccessfully to an `invoice.created` event can’t influence [automatic invoice finalization when using automatic collection](https://docs.stripe.com/billing/subscriptions/webhooks.md#understand). You must process this event type with a [webhook endpoint](https://docs.stripe.com/webhooks.md#example-endpoint) configured in a Stripe account within the organization to trigger automatic invoice finalization. ## Create a handler Use the Stripe API reference to identify the [thin event objects](https://docs.stripe.com/api/v2/events/event-types.md) or [snapshot event objects](https://docs.stripe.com/api/events/object.md) your webhook handler needs to process. Set up an HTTP or HTTPS endpoint function that can accept webhook requests with a POST method. If you’re still developing your endpoint function on your local machine, it can use HTTP. After it’s publicly accessible, your webhook endpoint function must use HTTPS. Set up your endpoint function so that it: - Handles POST requests with a JSON payload consisting of an [event object](https://docs.stripe.com/api/events/object.md). - For [organization](https://docs.stripe.com/get-started/account/orgs.md) event handlers, it inspects the `context` value to determine which account in an organization generated the event, then sets the `Stripe-Context` header corresponding to the `context` value. - Quickly returns a successful status code (`2xx`) prior to any complex logic that might cause a timeout. For example, you must return a `200` response before updating a customer’s invoice as paid in your accounting system. > Use our [interactive webhook endpoint builder](https://docs.stripe.com/webhooks/quickstart.md) to build a webhook endpoint function in your programming language. #### Example endpoint This code snippet is a webhook function configured to check for received events from a Stripe account, handle the events, and return a `200` responses. Reference the [snapshot](https://docs.stripe.com/event-destinations.md#events-overview) event handler when you use API v1 resources, and reference the [thin](https://docs.stripe.com/event-destinations.md#events-overview) event handler when you use API v2 resources. #### Snapshot event handler When you create a snapshot event handler, use the API object definition at the time of the event for your logic by accessing the event’s `data.object` fields. You can also retrieve the API resource from the Stripe API to access the latest and up-to-date object definition. #### Ruby ```ruby require 'json' # Replace this endpoint secret with your unique endpoint secret key # If you're testing with the CLI, run 'stripe listen' to find the secret key # If you defined your endpoint using the API or the Dashboard, check your webhook settings for your endpoint secret: https://dashboard.stripe.com/webhooks endpoint_secret = 'whsec_...'; # Using Sinatra post '/webhook' do payload = request.body.read event = nil begin event = Stripe::Event.construct_from( JSON.parse(payload, symbolize_names: true) ) rescue JSON::ParserError => e # Invalid payload status 400 return end # Check that you have configured webhook signing if endpoint_secret # Retrieve the event by verifying the signature using the raw body and the endpoint secret signature = request.env['HTTP_STRIPE_SIGNATURE']; begin event = Stripe::Webhook.construct_event( payload, signature, endpoint_secret ) rescue Stripe::SignatureVerificationError => e puts \"⚠️ Webhook signature verification failed. #{e.message}\" status 400 end end # Handle the event case event.type when 'payment_intent.succeeded' payment_intent = event.data.object # contains a Stripe::PaymentIntent # Then define and call a method to handle the successful payment intent. # handle_payment_intent_succeeded(payment_intent) when 'payment_method.attached' payment_method = event.data.object # contains a Stripe::PaymentMethod # Then define and call a method to handle the successful attachment of a PaymentMethod. # handle_payment_method_attached(payment_method) # ... handle other event types else puts \"Unhandled event type: #{event.type}\" end status 200 end ``` #### Python ```python import json from django.http import HttpResponse # Using Django # Replace this endpoint secret with your unique endpoint secret key # If you're testing with the CLI, run 'stripe listen' to find the secret key # If you defined your endpoint using the API or the Dashboard, check your webhook settings for your endpoint secret: https://dashboard.stripe.com/webhooks endpoint_secret = 'whsec_...' @csrf_exempt def my_webhook_view(request): payload = request.body event = None try: event = stripe.Event.construct_from( json.loads(payload), stripe.api_key ) except ValueError as e: # Invalid payload return HttpResponse(status=400) if endpoint_secret: # Only verify the event if you've defined an endpoint secret # Otherwise, use the basic event deserialized with JSON sig_header = request.headers.get('stripe-signature') try: event = stripe.Webhook.construct_event( payload, sig_header, endpoint_secret ) except stripe.error.SignatureVerificationError as e: print('⚠️ Webhook signature verification failed.' + str(e)) return jsonify(success=False) # Handle the event if event.type == 'payment_intent.succeeded': payment_intent = event.data.object # contains a stripe.PaymentIntent # Then define and call a method to handle the successful payment intent. # handle_payment_intent_succeeded(payment_intent) elif event.type == 'payment_method.attached': payment_method = event.data.object # contains a stripe.PaymentMethod # Then define and call a method to handle the successful attachment of a PaymentMethod. # handle_payment_method_attached(payment_method) # ... handle other event types else: print('Unhandled event type {}'.format(event.type)) return HttpResponse(status=200) ``` #### PHP ```php // Replace this endpoint secret with your unique endpoint secret key // If you're testing with the CLI, run 'stripe listen' to find the secret key // # If you defined your endpoint using the API or the Dashboard, check your webhook settings for your endpoint secret: https://dashboard.stripe.com/webhooks $endpoint_secret = 'whsec_...'; $payload = @file_get_contents('php://input'); $event = null; try { $event = \\Stripe\\Event::constructFrom( json_decode($payload, true) ); } catch(\\UnexpectedValueException $e) { // Invalid payload http_response_code(400); exit(); } if ($endpoint_secret) { // Only verify the event if you've defined an endpoint secret // Otherwise, use the basic decoded event $sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE']; try { $event = \\Stripe\\Webhook::constructEvent( $payload, $sig_header, $endpoint_secret ); } catch(\\Stripe\\Exception\\SignatureVerificationException $e) { // Invalid signature echo '⚠️ Webhook error while validating signature.'; http_response_code(400); exit(); } } // Handle the event switch ($event->type) { case 'payment_intent.succeeded': $paymentIntent = $event->data->object; // contains a \\Stripe\\PaymentIntent // Then define and call a method to handle the successful payment intent. // handlePaymentIntentSucceeded($paymentIntent); break; case 'payment_method.attached': $paymentMethod = $event->data->object; // contains a \\Stripe\\PaymentMethod // Then define and call a method to handle the successful attachment of a PaymentMethod. // handlePaymentMethodAttached($paymentMethod); break; // ... handle other event types default: echo 'Received unknown event type ' . $event->type; } http_response_code(200); ``` #### Java ```java // Using the Spark framework (http://sparkjava.com) public Object handle(Request request, Response response) { // Replace this endpoint secret with your unique endpoint secret key // If you're testing with the CLI, run 'stripe listen' to find the secret key // I# If you defined your endpoint using the API or the Dashboard, check your webhook settings for your endpoint secret: https://dashboard.stripe.com/webhooks String endpointSecret = \"whsec_...\"; String payload = request.body(); Event event = null; try { event = ApiResource.GSON.fromJson(payload, Event.class); } catch (JsonSyntaxException e) { // Invalid payload response.status(400); return \"\"; } String sigHeader = request.headers(\"Stripe-Signature\"); if(endpointSecret != null && sigHeader != null) { // Only verify the event if you’ve defined an endpoint secret // Otherwise, use the basic event deserialized with GSON try { event = Webhook.constructEvent( payload, sigHeader, endpointSecret ); } catch (SignatureVerificationException e) { // Invalid signature System.out.println(\"⚠️ Webhook error while validating signature.\"); response.status(400); return \"\"; } } // Deserialize the nested object inside the event EventDataObjectDeserializer dataObjectDeserializer = event.getDataObjectDeserializer(); StripeObject stripeObject = null; if (dataObjectDeserializer.getObject().isPresent()) { stripeObject = dataObjectDeserializer.getObject().get(); } else { // Deserialization failed, probably due to an API version mismatch. // Refer to the Javadoc documentation on `EventDataObjectDeserializer` for // instructions on how to handle this case, or return an error here. } // Handle the event switch (event.getType()) { case \"payment_intent.succeeded\": PaymentIntent paymentIntent = (PaymentIntent) stripeObject; // Then define and call a method to handle the successful payment intent. // handlePaymentIntentSucceeded(paymentIntent); break; case \"payment_method.attached\": PaymentMethod paymentMethod = (PaymentMethod) stripeObject; // Then define and call a method to handle the successful attachment of a PaymentMethod. // handlePaymentMethodAttached(paymentMethod); break; // ... handle other event types default: System.out.println(\"Unhandled event type: \" + event.getType()); } response.status(200); return \"\"; } ``` #### Node.js ```javascript const express = require('express'); const app = express(); // Replace this endpoint secret with your unique endpoint secret key // If you're testing with the CLI, run 'stripe listen' to find the secret key // If you defined your endpoint using the API or the Dashboard, check your webhook settings for your endpoint secret: https://dashboard.stripe.com/webhooks const endpointSecret = 'whsec_...'; // The express.raw middleware keeps the request body unparsed; // this is necessary for the signature verification process app.post('/webhook', express.raw({type: 'application/json'}), (request, response) => { let event; if (endpointSecret) { // Get the signature sent by Stripe const signature = request.headers['stripe-signature']; try { event = stripe.webhooks.constructEvent( request.body, signature, endpointSecret ); } catch (err) { console.log(`⚠️ Webhook signature verification failed.`, err.message); return response.sendStatus(400); } // Handle the event switch (event.type) { case 'payment_intent.succeeded': const paymentIntent = event.data.object; // Then define and call a method to handle the successful payment intent. // handlePaymentIntentSucceeded(paymentIntent); break; case 'payment_method.attached': const paymentMethod = event.data.object; // Then define and call a method to handle the successful attachment of a PaymentMethod. // handlePaymentMethodAttached(paymentMethod); break; // ... handle other event types default: console.log(`Unhandled event type ${event.type}`); } // Return a response to acknowledge receipt of the event response.json({received: true}); }); app.listen(4242, () => console.log('Running on port 4242')); ``` #### Go ```go http.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) { const MaxBodyBytes = int64(65536) req.Body = http.MaxBytesReader(w, req.Body, MaxBodyBytes) payload, err := ioutil.ReadAll(req.Body) if err != nil { fmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err) w.WriteHeader(http.StatusServiceUnavailable) return } event := stripe.Event{} if err := json.Unmarshal(payload, &event); err != nil { fmt.Fprintf(os.Stderr, \"Failed to parse webhook body json: %v\\n\", err.Error()) w.WriteHeader(http.StatusBadRequest) return } // Unmarshal the event data into an appropriate struct depending on its Type switch event.Type { case \"payment_intent.succeeded\": var paymentIntent stripe.PaymentIntent err := json.Unmarshal(event.Data.Raw, &paymentIntent) if err != nil { fmt.Fprintf(os.Stderr, \"Error parsing webhook JSON: %v\\n\", err) w.WriteHeader(http.StatusBadRequest) return } // Then define and call a func to handle the successful payment intent. // handlePaymentIntentSucceeded(paymentIntent) case \"payment_method.attached\": var paymentMethod stripe.PaymentMethod err := json.Unmarshal(event.Data.Raw, &paymentMethod) if err != nil { fmt.Fprintf(os.Stderr, \"Error parsing webhook JSON: %v\\n\", err) w.WriteHeader(http.StatusBadRequest) return } // Then define and call a func to handle the successful attachment of a PaymentMethod. // handlePaymentMethodAttached(paymentMethod) // ... handle other event types default: fmt.Fprintf(os.Stderr, \"Unhandled event type: %s\\n\", event.Type) } w.WriteHeader(http.StatusOK) }) ``` #### .NET ```csharp using System; using System.IO; using Microsoft.AspNetCore.Mvc; using Stripe; namespace workspace.Controllers { [Route(\"api/[controller]\")] public class StripeWebHook : Controller { [HttpPost] public async Task Index() { var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync(); const string endpointSecret = \"whsec_...\"; try { var stripeEvent = EventUtility.ParseEvent(json); var signatureHeader = Request.Headers[\"Stripe-Signature\"]; stripeEvent = EventUtility.ConstructEvent(json,signatureHeader, endpointSecret); // Handle the event // If on SDK version < 46, use class Events instead of EventTypes if (stripeEvent.Type == EventTypes.PaymentIntentSucceeded) { var paymentIntent = stripeEvent.Data.Object as PaymentIntent; // Then define and call a method to handle the successful payment intent. // handlePaymentIntentSucceeded(paymentIntent); } else if (stripeEvent.Type == EventTypes.PaymentMethodAttached) { var paymentMethod = stripeEvent.Data.Object as PaymentMethod; // Then define and call a method to handle the successful attachment of a PaymentMethod. // handlePaymentMethodAttached(paymentMethod); } // ... handle other event types else { // Unexpected event type Console.WriteLine(\"Unhandled event type: {0}\", stripeEvent.Type); } return Ok(); } catch (StripeException e) { return BadRequest(); } } } } ``` #### Thin event handler (Clover+) When you create a thin event handler, use the `fetchRelatedObject()` method to retrieve the latest version of the object associated with the event. Events might contain [additional data](https://docs.stripe.com/event-destinations.md#fetch-data) that you can only retrieve through the `.fetchEvent()` instance method on `EventNotification`. The exact shape of that data depends on the `type` of the Event. Event types must be available at the time of release to generate classes in that SDK version. To handle Events the SDK doesn’t have classes for, use the `UnknownEventNotification` class. #### Python ```python import os from stripe import StripeClient from stripe.events import UnknownEventNotification from flask import Flask, request, jsonify app = Flask(__name__) api_key = os.environ.get(\"STRIPE_API_KEY\", \"\") webhook_secret = os.environ.get(\"WEBHOOK_SECRET\", \"\") client = StripeClient(api_key) @app.route(\"/webhook\", methods=[\"POST\"]) def webhook(): webhook_body = request.data sig_header = request.headers.get(\"Stripe-Signature\") try: event_notif = client.parse_event_notification( webhook_body, sig_header, webhook_secret ) # type checkers will narrow the type based on the `type` property if event_notif.type == \"v1.billing.meter.error_report_triggered\": # in this block, event_notification is typed as # a V1BillingMeterErrorReportTriggeredEventNotification # there's basic info about the related object in the notification print(f\"Meter w/ id {event_notif.related_object.id} had a problem\") # or you can fetch the full object form the API for more details meter = event_notif.fetch_related_object() print( f\"Meter {meter.display_name} ({meter.id}) had a problem\" ) # And you can always fetch the full event: event = event_notif.fetch_event() print(f\"More info: {event.data.developer_message_summary}\") elif event_notif.type == \"v1.billing.meter.no_meter_found\": # in this block, event_notification is typed as # a V1BillingMeterNoMeterFoundEventNotification # that class doesn't define `fetch_related_object` because the event # has no related object. # so this line would correctly give a type error: # meter = event_notif.fetch_related_object() # but fetching the event always works: event = event_notif.fetch_event() print( f\"Err! No meter found: {event.data.developer_message_summary}\" ) # Events that were introduced after this SDK version release are # represented as `UnknownEventNotification`s. # They're valid, the SDK just doesn't have corresponding classes for them. # You must match on the \"type\" property instead. elif isinstance(event_notif, UnknownEventNotification): # these lines are optional, but will give you more accurate typing in this block from typing import cast event_notif = cast(UnknownEventNotification, event_notif) # continue matching on the type property # from this point on, the `related_object` property _may_ be None # (depending on the event type) if event_notif.type == \"some.new.event\": # if this event type has a related object, you can fetch it obj = event_notif.fetch_related_object() # otherwise, `obj` will just be `None` print(f\"Related object: {obj}\") # you can still fetch the full event, but it will be untyped event = event_notif.fetch_event() print(f\"New event: {event.data}\") # type: ignore return jsonify(success=True), 200 except Exception as e: return jsonify(error=str(e)), 400 ``` #### Ruby ```ruby require \"stripe\" require \"sinatra\" api_key = ENV.fetch(\"STRIPE_API_KEY\", nil) # Retrieve the webhook secret from the environment variable webhook_secret = ENV.fetch(\"WEBHOOK_SECRET\", nil) client = Stripe::StripeClient.new(api_key) post \"/webhook\" do webhook_body = request.body.read sig_header = request.env[\"HTTP_STRIPE_SIGNATURE\"] event_notification = client.parse_event_notification(webhook_body, sig_header, webhook_secret) if event_notification.instance_of?(Stripe::Events::V1BillingMeterErrorReportTriggeredEventNotification) # there's basic info about the related object in the notification puts \"Received event for meter id:\", event_notification.related_object.id # or you can fetch the full object form the API for more details meter = event_notification.fetch_related_object puts \"Meter #{meter.display_name} (#{meter.id}) had a problem\" # And you can always fetch the full event: event = event_notification.fetch_event puts \"More info:\", event.data.developer_message_summary elsif event_notification.instance_of?(Stripe::Events::UnknownEventNotification) # Events that were introduced after this SDK version release are # represented as `UnknownEventNotification`s. # They're valid, the SDK just doesn't have corresponding classes for them. # You must match on the \"type\" property instead. if event_notification.type == \"some.new.event\" # your logic goes here end end # Record the failures and alert your team status 200 end ``` #### PHP ```php post('/webhook', static function ($request, $response) use ($client, $webhook_secret) { $webhook_body = $request->getBody()->getContents(); $sig_header = $request->getHeaderLine('Stripe-Signature'); try { $event_notification = $client->parseEventNotification($webhook_body, $sig_header, $webhook_secret); // check what type of event notification we have if ($event_notification instanceof Stripe\\Events\\V1BillingMeterErrorReportTriggeredEventNotification) { // there's basic info about the related object in the notification echo \"Meter with id {$event_notification->related_object->id} reported an error\\n\"; // or you can fetch the full object form the API for more details $meter = $event_notification->fetchRelatedObject(); echo \"Meter {$meter->display_name} ({$meter->id}) had a problem\\n\"; # And you can always fetch the full event: $event = $event_notification->fetchEvent(); echo \"More info: {$event->data->developer_message_summary}\\n\"; } else if ($event_notification instanceof Stripe\\Events\\UnknownEventNotification) { // Events that were introduced after this SDK version release are // represented as `UnknownEventNotification`s. // They're valid, the SDK just doesn't have corresponding classes for them. // You must match on the \"type\" property instead. if ($event_notification->type === 'some.new.event') { // handle it the same way as above } } return $response->withStatus(200); } catch (Exception $e) { return $response->withStatus(400)->withJson(['error' => $e->getMessage()]); } }); $app->run(); ``` #### Java ```java import com.stripe.StripeClient; import com.stripe.events.UnknownEventNotification; import com.stripe.events.V1BillingMeterErrorReportTriggeredEvent; import com.stripe.events.V1BillingMeterErrorReportTriggeredEventNotification; import com.stripe.exception.StripeException; import com.stripe.model.billing.Meter; import com.stripe.model.v2.core.EventNotification; import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.InetSocketAddress; import java.nio.charset.StandardCharsets; public class EventNotificationWebhookHandler { private static final String API_KEY = System.getenv(\"STRIPE_API_KEY\"); private static final String WEBHOOK_SECRET = System.getenv(\"WEBHOOK_SECRET\"); private static final StripeClient client = new StripeClient(API_KEY); public static void main(String[] args) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(4242), 0); server.createContext(\"/webhook\", new WebhookHandler()); server.setExecutor(null); server.start(); } static class WebhookHandler implements HttpHandler { @Override public void handle(HttpExchange exchange) throws IOException { if (\"POST\".equals(exchange.getRequestMethod())) { InputStream requestBody = exchange.getRequestBody(); String webhookBody = new String(requestBody.readAllBytes(), StandardCharsets.UTF_8); String sigHeader = exchange.getRequestHeaders().getFirst(\"Stripe-Signature\"); try { EventNotification notif = client.parseEventNotification(webhookBody, sigHeader, WEBHOOK_SECRET); if (notif instanceof V1BillingMeterErrorReportTriggeredEventNotification) { V1BillingMeterErrorReportTriggeredEventNotification eventNotification = (V1BillingMeterErrorReportTriggeredEventNotification) notif; // there's basic info about the related object in the notification System.out.println( \"Meter w/ id \" + eventNotification.getRelatedObject().getId() + \" had a problem\"); // or you can fetch the full object form the API for more details Meter meter = eventNotification.fetchRelatedObject(); StringBuilder sb = new StringBuilder(); sb.append(\"Meter \") .append(meter.getDisplayName()) .append(\" (\") .append(meter.getId()) .append(\") had a problem\"); System.out.println(sb.toString()); // And you can always fetch the full event: V1BillingMeterErrorReportTriggeredEvent event = eventNotification.fetchEvent(); System.out.println(\"More info: \" + event.getData().getDeveloperMessageSummary()); } else if (notif instanceof UnknownEventNotification) { // Events that were introduced after this SDK version release are // represented as `UnknownEventNotification`s. // They're valid, the SDK just doesn't have corresponding classes for them. // You must match on the \"type\" property instead. UnknownEventNotification unknownEvent = (UnknownEventNotification) notif; if (unknownEvent.getType().equals(\"some.new.event\")) { // you can still `.fetchEvent()` and `.fetchRelatedObject()`, but the latter may // return `null` if that event type doesn't have a related object. } } exchange.sendResponseHeaders(200, -1); } catch (StripeException e) { exchange.sendResponseHeaders(400, -1); } } else { exchange.sendResponseHeaders(405, -1); } exchange.close(); } } } ``` #### Typescript ```typescript import {Stripe} from 'stripe'; import express from 'express'; const app = express(); const apiKey = process.env.STRIPE_API_KEY ?? ''; const webhookSecret = process.env.WEBHOOK_SECRET ?? ''; const client = new Stripe(apiKey); app.post( '/webhook', express.raw({type: 'application/json'}), async (req, res) => { const sig = req.headers['stripe-signature'] ?? ''; try { const eventNotification = client.parseEventNotification( req.body, sig, webhookSecret ); // TS will narrow event based on the `type` property if (eventNotification.type == 'v1.billing.meter.error_report_triggered') { // this this block, eventNotification is correctly // a Stripe.Events.V1BillingMeterErrorReportTriggeredEventNotification // there's basic info about the related object in the notification console.log( `Meter w/ id ${eventNotification.related_object.id} had a problem` ); // or you can fetch the full object from the API for more details const meter = await eventNotification.fetchRelatedObject(); console.log(`Meter ${meter.display_name} (${meter.id}) had a problem`); // And you can always fetch the full event: const event = await eventNotification.fetchEvent(); console.log(`More info: ${event.data.developer_message_summary}`); } else if (eventNotification.type === 'v1.billing.meter.no_meter_found') { // in this block, eventNotification is correctly // a Stripe.Events.V1BillingMeterNoMeterFoundEventNotification // that interface doesn't define `fetchRelatedObject()` because the event // has no related object. so this line would correctly give a type error: // eventNotification.fetchRelatedObject(); // but fetching the event always works: const event = await eventNotification.fetchEvent(); console.log( `Err: No meter found: ${event.data.developer_message_summary}` ); // Events that were introduced after this SDK version release are // represented as `UnknownEventNotification`s. // They're valid, the SDK just doesn't have corresponding classes for them. // In that case, you ignore the type mismatch and cast to UnknownEventNotification // @ts-expect-error } else if (eventNotification.type === 'some.new.event') { const unknownEvent = eventNotification as Stripe.Events.UnknownEventNotification; // you can still fetch the related object, if one exists // but its type is `unknown` const obj = await unknownEvent.fetchRelatedObject(); // and you can still fetch the event: const event = await unknownEvent.fetchEvent(); // @ts-expect-error console.log(`Got new event: ${event.data}`); } res.sendStatus(200); } catch (err) { console.log(`Webhook Error: ${(err as any).stack}`); res.status(400).send(`Webhook Error: ${(err as any).message}`); } } ); app.listen(4242, () => console.log('Running on port 4242')); ``` #### Go ```go package main import ( \"context\" \"io\" \"log/slog\" \"net/http\" \"os\" \"github.com/stripe/stripe-go/v83\" ) func main() { http.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) { const MaxBodyBytes = int64(65536) req.Body = http.MaxBytesReader(w, req.Body, MaxBodyBytes) payload, err := io.ReadAll(req.Body) if err != nil { fmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err) w.WriteHeader(http.StatusInternalServerError) return } eventNotification, err := client.ParseEventNotification(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret) if err != nil { fmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err) w.WriteHeader(http.StatusInternalServerError) return } // Unmarshal the event data into an appropriate struct depending on its Type switch evt := eventNotification.(type) { case *stripe.V1BillingMeterErrorReportTriggeredEventNotification: // there's basic info about the related object in the notification fmt.Printf(\"Meter w/ id %s had a problem\\n\", evt.RelatedObject.ID) // or you can fetch the full object form the API for more details meter, err := evt.FetchRelatedObject(context.TODO()) if err != nil { fmt.Fprintf(os.Stderr, \"Error fetching related object: %v\\n\", err) w.WriteHeader(http.StatusInternalServerError) return } sb := fmt.Sprintf(\"Meter %s (%s) had a problem\", meter.DisplayName, meter.ID) fmt.Println(sb) // And you can always fetch the full event: event, err := evt.FetchEvent(context.TODO()) if err != nil { fmt.Fprintf(os.Stderr, \"Error fetching event: %v\\n\", err) w.WriteHeader(http.StatusInternalServerError) return } fmt.Printf(\"More info: %s\\n\", event.Data.DeveloperMessageSummary) case *stripe.UnknownEventNotification: // Events that were introduced after this SDK version release are // represented as `UnknownEventNotification`s. // They're valid, the SDK just doesn't have corresponding classes for them. // You must match on the \"type\" property instead. switch evt.Type { case \"some.new.event\": // you can still `.FetchEvent()` and `.FetchRelatedObject()`, but the latter may // return `nil` if that event type doesn't have a related object. return } default: fmt.Fprintf(os.Stderr, \"Purposefully skipping the handling of event w/ type: %s\\n\", evt.GetEventNotification().Type) } w.WriteHeader(http.StatusOK) }) err := http.ListenAndServe(\":4242\", nil) if err != nil { fmt.Println(err) os.Exit(1) } } ``` #### .NET ```csharp using System; using System.IO; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Stripe; using Stripe.Events; [Route(\"api/[controller]\")] [ApiController] public class EventNotificationWebhookHandler : ControllerBase { private readonly StripeClient client; private readonly string webhookSecret; public EventNotificationWebhookHandler() { var apiKey = Environment.GetEnvironmentVariable(\"STRIPE_API_KEY\"); client = new StripeClient(apiKey); webhookSecret = Environment.GetEnvironmentVariable(\"WEBHOOK_SECRET\") ?? string.Empty; } [HttpPost] public async Task Index() { var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync(); try { var eventNotification = client.ParseEventNotification(json, Request.Headers[\"Stripe-Signature\"], webhookSecret); // match on the type of the class to determine what event you have if (eventNotification is V1BillingMeterErrorReportTriggeredEventNotification notif) { // there's basic info about the related object in the notification Console.WriteLine( $\"Meter w/ id {notif.RelatedObject.Id} had a problem\"); // or you can fetch the full object form the API for more details var meter = await notif.FetchRelatedObjectAsync(); Console.WriteLine($\"Meter {meter.DisplayName} ({meter.Id}) had a problem\"); // And you can always fetch the full event: var evt = await notif.FetchEventAsync(); Console.WriteLine($\"More info: {evt.Data.DeveloperMessageSummary}\"); } else if (eventNotification is UnknownEventNotification unknownEvt) { // Events that were introduced after this SDK version release are // represented as `UnknownEventNotification`s. // They're valid, the SDK just doesn't have corresponding classes for them. // You must match on the \"type\" property instead. if (unknownEvt.Type == \"some.other.event\") { // you can still `.fetchEvent()` and `.fetchRelatedObject()`, but the latter may // return `null` if that event type doesn't have a related object. } } return Ok(); } catch (StripeException e) { return BadRequest(e.Message); } } } ``` #### Thin event handler (Acacia or Basil) When you create a thin event handler, use the `fetchRelatedObject()` method to retrieve the latest version of the object associated with the event. Thin events might contain [additional contextual data](https://docs.stripe.com/event-destinations.md#fetch-data) that you can only retrieve with the API. Use the `retrieve()` call with the thin event ID to access these additional payload fields. #### Python ```python import os from stripe import StripeClient from stripe.events import V1BillingMeterErrorReportTriggeredEvent from flask import Flask, request, jsonify app = Flask(__name__) api_key = os.environ.get('STRIPE_API_KEY') webhook_secret = os.environ.get('WEBHOOK_SECRET') client = StripeClient(api_key) @app.route('/webhook', methods=['POST']) def webhook(): webhook_body = request.data sig_header = request.headers.get('Stripe-Signature') try: thin_event = client.parse_thin_event(webhook_body, sig_header, webhook_secret) # Fetch the event data to understand the failure event = client.v2.core.events.retrieve(thin_event.id) if isinstance(event, V1BillingMeterErrorReportTriggeredEvent): meter = event.fetch_related_object() meter_id = meter.id # Record the failures and alert your team # Add your logic here return jsonify(success=True), 200 except Exception as e: return jsonify(error=str(e)), 400 if __name__ == '__main__': app.run(port=4242) ``` #### Ruby ```ruby require \"stripe\" require \"sinatra\" api_key = ENV.fetch(\"STRIPE_API_KEY\", nil) # Retrieve the webhook secret from the environment variable webhook_secret = ENV.fetch(\"WEBHOOK_SECRET\", nil) client = Stripe::StripeClient.new(api_key) post \"/webhook\" do webhook_body = request.body.read sig_header = request.env[\"HTTP_STRIPE_SIGNATURE\"] thin_event = client.parse_thin_event(webhook_body, sig_header, webhook_secret) # Fetch the event data to understand the failure event = client.v2.core.events.retrieve(thin_event.id) if event.instance_of? Stripe::V1BillingMeterErrorReportTriggeredEvent meter = event.fetch_related_object meter_id = meter.id end # Record the failures and alert your team # Add your logic here status 200 end ``` #### PHP ```php post('/webhook', function ($request, $response) use ($client, $webhook_secret) { $webhook_body = $request->getBody()->getContents(); $sig_header = $request->getHeaderLine('Stripe-Signature'); try { $thin_event = $client->parseThinEvent($webhook_body, $sig_header, $webhook_secret); // Fetch the event data to understand the failure $event = $client->v2->core->events->retrieve($thin_event->id); if ($event instanceof \\Stripe\\Events\\V1BillingMeterErrorReportTriggeredEvent) { $meter = $event->fetchRelatedObject(); $meter_id = $meter->id; // Record the failures and alert your team // Add your logic here } return $response->withStatus(200); } catch (\\Exception $e) { return $response->withStatus(400)->withJson(['error' => $e->getMessage()]); } }); $app->run(); ``` #### Java ```java import com.stripe.StripeClient; import com.stripe.events.V1BillingMeterErrorReportTriggeredEvent; import com.stripe.exception.StripeException; import com.stripe.model.ThinEvent; import com.stripe.model.billing.Meter; import com.stripe.model.v2.Event; import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import java.io.IOException; import java.io.InputStream; import java.net.InetSocketAddress; import java.nio.charset.StandardCharsets; public class StripeWebhookHandler { private static final String API_KEY = System.getenv(\"STRIPE_API_KEY\"); private static final String WEBHOOK_SECRET = System.getenv(\"WEBHOOK_SECRET\"); private static final StripeClient client = new StripeClient(API_KEY); public static void main(String[] args) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(4242), 0); server.createContext(\"/webhook\", new WebhookHandler()); server.setExecutor(null); server.start(); } static class WebhookHandler implements HttpHandler { @Override public void handle(HttpExchange exchange) throws IOException { if (\"POST\".equals(exchange.getRequestMethod())) { InputStream requestBody = exchange.getRequestBody(); String webhookBody = new String(requestBody.readAllBytes(), StandardCharsets.UTF_8); String sigHeader = exchange.getRequestHeaders().getFirst(\"Stripe-Signature\"); try { ThinEvent thinEvent = client.parseThinEvent(webhookBody, sigHeader, WEBHOOK_SECRET); // Fetch the event data to understand the failure Event baseEvent = client.v2().core().events().retrieve(thinEvent.getId()); if (baseEvent instanceof V1BillingMeterErrorReportTriggeredEvent) { V1BillingMeterErrorReportTriggeredEvent event = (V1BillingMeterErrorReportTriggeredEvent) baseEvent; Meter meter = event.fetchRelatedObject(); String meterId = meter.getId(); // Record the failures and alert your team // Add your logic here } exchange.sendResponseHeaders(200, -1); } catch (StripeException e) { exchange.sendResponseHeaders(400, -1); } } else { exchange.sendResponseHeaders(405, -1); } exchange.close(); } } } ``` #### Node.js ```javascript const express = require('express'); const {Stripe} = require('stripe'); const app = express(); const apiKey = process.env.STRIPE_API_KEY; const webhookSecret = process.env.WEBHOOK_SECRET; const client = new Stripe(apiKey); app.post( '/webhook', express.raw({type: 'application/json'}), async (req, res) => { const sig = req.headers['stripe-signature']; try { const thinEvent = client.parseThinEvent(req.body, sig, webhookSecret); // Fetch the event data to understand the failure const event = await client.v2.core.events.retrieve(thinEvent.id); if (event.type == 'v1.billing.meter.error_report_triggered') { const meter = await event.fetchRelatedObject(); const meterId = meter.id; // Record the failures and alert your team // Add your logic here } res.sendStatus(200); } catch (err) { console.log(`Webhook Error: ${err.message}`); res.status(400).send(`Webhook Error: ${err.message}`); } }, ); app.listen(4242, () => console.log('Running on port 4242')); ``` #### Go ```go package main import ( \"context\" \"io\" \"log/slog\" \"net/http\" \"os\" \"github.com/stripe/stripe-go/v82\" ) func main() { apiKey := os.Getenv(\"STRIPE_API_KEY\") webhookSecret := os.Getenv(\"STRIPE_WEBHOOK_SECRET\") client := stripe.NewClient(apiKey) http.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) { defer req.Body.Close() payload, err := io.ReadAll(req.Body) if err != nil { slog.Error(\"Reading request body\", \"error\", err) w.WriteHeader(http.StatusInternalServerError) return } thinEvent, err := client.ParseThinEvent(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret) if err != nil { slog.Error(\"Parsing thin event\", \"error\", err) w.WriteHeader(http.StatusInternalServerError) return } event, err := client.V2CoreEvents.Retrieve(context.TODO(), thinEvent.ID, nil) if err != nil { slog.Error(\"Retrieving snapshot event\", \"error\", err) w.WriteHeader(http.StatusInternalServerError) return } switch e := event.(type) { case *stripe.V1BillingMeterErrorReportTriggeredEvent: meter, err := e.FetchRelatedObject() if err != nil { slog.Error(\"Error fetching related object\", \"error\", err) w.WriteHeader(http.StatusInternalServerError) return } meterID := meter.ID // Add your logic here } w.WriteHeader(http.StatusOK) }) err := http.ListenAndServe(\":4242\", nil) if err != nil { slog.Error(\"Starting server\", \"error\", err) os.Exit(1) } } ``` #### .NET ```csharp using System; using System.IO; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Stripe; using Stripe.Events; [Route(\"api/[controller]\")] [ApiController] public class WebhookController : ControllerBase { private readonly StripeClient _client; private readonly string _webhookSecret; public WebhookController() { var apiKey = Environment.GetEnvironmentVariable(\"STRIPE_API_KEY\"); _client = new StripeClient(apiKey); _webhookSecret = Environment.GetEnvironmentVariable(\"WEBHOOK_SECRET\"); } [HttpPost] public async Task Index() { var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync(); try { var thinEvent = _client.ParseThinEvent(json, Request.Headers[\"Stripe-Signature\"], _webhookSecret); // Fetch the event data to understand the failure var baseEvent = await _client.V2.Core.Events.GetAsync(thinEvent.Id); if (baseEvent is V1BillingMeterErrorReportTriggeredEvent fullEvent) { var meter = await fullEvent.FetchRelatedObjectAsync(); var meterId = meter.Id; // Record the failures and alert your team // Add your logic here } return Ok(); } catch (StripeException e) { return BadRequest(e.Message); } } } ``` #### Using `context` #### Snapshot events This code snippet is a webhook function configured to check for received events, detect the originating account if applicable, handle the event, and return a `200` response. #### Ruby ```ruby require 'json' # Using Sinatra post '/webhook' do payload = request.body.read event = nil begin event = Stripe::Event.construct_from( JSON.parse(payload, symbolize_names: true) ) rescue JSON::ParserError => e # Invalid payload status 400 return end # Extract the context context = event.context # Define your API key variables (ideally loaded securely) ACCOUNT_123_API_KEY = \"sk_test_[REDACTED]\" ACCOUNT_456_API_KEY = \"sk_test_[REDACTED]\" account_api_keys = { \"account_123\" => ACCOUNT_123_API_KEY, \"account_456\" => ACCOUNT_456_API_KEY } api_key = account_api_keys[context] if api_key.nil? puts \"No API key found for context: #{context}\" status 400 return end # Handle the event case event.type when 'customer.created' customer = event.data.object begin latest_customer = Stripe::Customer.retrieve( customer.id, { api_key: api_key } ) handle_customer_created(latest_customer, context) rescue => e puts \"Error retrieving customer: #{e.message}\" status 500 return end when 'payment_method.attached' payment_method = event.data.object begin latest_payment_method = Stripe::PaymentMethod.retrieve( payment_method.id, { api_key: api_key } ) handle_payment_method_attached(latest_payment_method, context) rescue => e puts \"Error retrieving payment method: #{e.message}\" status 500 return end else puts \"Unhandled event type: #{event.type}\" end status 200 end ``` #### Python ```python import json from django.http import HttpResponse from django.views.decorators.csrf import csrf_exempt # Define API key variables (in production, pull these from environment variables or secret manager) ACCOUNT_123_API_KEY = \"sk_test_[REDACTED]\" ACCOUNT_456_API_KEY = \"sk_test_[REDACTED]\" account_api_keys = { \"account_123\": ACCOUNT_123_API_KEY, \"account_456\": ACCOUNT_456_API_KEY, } @csrf_exempt def my_webhook_view(request): payload = request.body event = None try: event = stripe.Event.construct_from( json.loads(payload.decode('utf-8')), stripe.api_key ) except ValueError as e: # Invalid payload return HttpResponse(status=400) # Extract context context = getattr(event, \"context\", None) if context is None: print(\"Missing context in event.\") return HttpResponse(status=400) api_key = account_api_keys.get(context) if api_key is None: print(f\"No API key found for context: {context}\") return HttpResponse(status=400) # Handle the event if event.type == 'customer.created': customer = event.data.object try: latest_customer = stripe.Customer.retrieve(customer.id, api_key=api_key) handle_customer_created(latest_customer, context) except Exception as e: print(f\"Error retrieving customer: {e}\") return HttpResponse(status=500) elif event.type == 'payment_method.attached': payment_method = event.data.object try: latest_payment_method = stripe.PaymentMethod.retrieve(payment_method.id, api_key=api_key) handle_payment_method_attached(latest_payment_method, context) except Exception as e: print(f\"Error retrieving payment method: {e}\") return HttpResponse(status=500) else: print(f'Unhandled event type {event.type}') return HttpResponse(status=200) ``` #### Java ```java // Using the Spark framework public Object handle(Request request, Response response) { String payload = request.body(); Event event = null; try { event = ApiResource.GSON.fromJson(payload, Event.class); } catch (JsonSyntaxException e) { // Invalid payload response.status(400); return \"\"; } // Get context from event String context = event.getContext(); if (context == null || context.isEmpty()) { System.out.println(\"Missing context in event.\"); response.status(400); return \"\"; } // Define your API key variables (in production, pull from environment or secrets manager) final String ACCOUNT_123_API_KEY = \"sk_test_[REDACTED]\"; final String ACCOUNT_456_API_KEY = \"sk_test_[REDACTED]\"; Map accountApiKeys = new HashMap<>(); accountApiKeys.put(\"account_123\", ACCOUNT_123_API_KEY); accountApiKeys.put(\"account_456\", ACCOUNT_456_API_KEY); String apiKey = accountApiKeys.get(context); if (apiKey == null) { System.out.println(\"No API key found for context: \" + context); response.status(400); return \"\"; } // Deserialize the nested object inside the event EventDataObjectDeserializer dataObjectDeserializer = event.getDataObjectDeserializer(); if (!dataObjectDeserializer.getObject().isPresent()) { System.out.println(\"Unable to deserialize object from event.\"); response.status(400); return \"\"; } StripeObject stripeObject = dataObjectDeserializer.getObject().get(); // Set up RequestOptions with the correct API key RequestOptions requestOptions = RequestOptions.builder() .setApiKey(apiKey) .build(); try { switch (event.getType()) { case \"customer.created\": Customer customerEvent = (Customer) stripeObject; // Fetch the latest Customer from Stripe using the account's API key Customer latestCustomer = Customer.retrieve(customerEvent.getId(), requestOptions); handleCustomerCreated(latestCustomer, context); break; case \"payment_method.attached\": PaymentMethod paymentMethodEvent = (PaymentMethod) stripeObject; // Fetch the latest PaymentMethod from Stripe using the account's API key PaymentMethod latestPaymentMethod = PaymentMethod.retrieve(paymentMethodEvent.getId(), requestOptions); handlePaymentMethodAttached(latestPaymentMethod, context); break; // ... handle other event types default: System.out.println(\"Unhandled event type: \" + event.getType()); } } catch (StripeException e) { System.out.println(\"Stripe API error: \" + e.getMessage()); response.status(500); return \"\"; } response.status(200); return \"\"; } ``` #### Node.js ```javascript // This example uses Express to receive webhooks const express = require('express'); const app = express(); app.use(express.json({ type: 'application/json' })); // Define your API key variables (in production, load from environment variables or secrets) const ACCOUNT_123_API_KEY = 'sk_test_[REDACTED]'; const ACCOUNT_456_API_KEY = 'sk_test_[REDACTED]'; const accountApiKeys = { account_123: ACCOUNT_123_API_KEY, account_456: ACCOUNT_456_API_KEY, }; app.post('/webhook', async (request, response) => { const event = request.body; const context = event.context; if (!context) { console.error('Missing context in event'); return response.status(400).send('Missing context'); } const apiKey = accountApiKeys[context]; if (!apiKey) { console.error(`No API key found for context: ${context}`); return response.status(400).send('Unknown context'); } const stripe = Stripe(apiKey); try { switch (event.type) { case 'customer.created': { const customer = event.data.object; const latestCustomer = await stripe.customers.retrieve(customer.id); handleCustomerCreated(latestCustomer, context); break; } case 'payment_method.attached': { const paymentMethod = event.data.object; const latestPaymentMethod = await stripe.paymentMethods.retrieve(paymentMethod.id); handlePaymentMethodAttached(latestPaymentMethod, context); break; } // ... handle other event types default: console.log(`Unhandled event type ${event.type}`); } response.json({ received: true }); } catch (err) { console.error(`Error processing event: ${err.message}`); response.status(500).send('Internal error'); } }); app.listen(4242, () => console.log('Running on port 4242')); ``` #### .NET ```dotnet using System; using System.IO; using Microsoft.AspNetCore.Mvc; using Stripe; namespace workspace.Controllers { [Route(\"api/[controller]\")] public class StripeWebHook : Controller { // Define your API key variables (these should ideally come from secure config or env vars) private const string ACCOUNT_123_API_KEY = \"sk_test_[REDACTED]\"; private const string ACCOUNT_456_API_KEY = \"sk_test_[REDACTED]\"; private readonly Dictionary accountApiKeys = new() { { \"account_123\", ACCOUNT_123_API_KEY }, { \"account_456\", ACCOUNT_456_API_KEY } }; [HttpPost] public async Task Index() { var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync(); try { var stripeEvent = EventUtility.ParseEvent(json); var context = stripeEvent.Context; if (string.IsNullOrEmpty(context)) { Console.WriteLine(\"Missing context in event\"); return BadRequest(); } if (!accountApiKeys.TryGetValue(context, out var apiKey)) { Console.WriteLine($\"No API key found for context: {context}\"); return BadRequest(); } var requestOptions = new RequestOptions { ApiKey = apiKey }; // Handle the event if (stripeEvent.Type == Events.CustomerCreated) { var customerEvent = stripeEvent.Data.Object as Customer; if (customerEvent != null) { var customerService = new CustomerService(); var latestCustomer = await customerService.GetAsync(customerEvent.Id, null, requestOptions); HandleCustomerCreated(latestCustomer, context); } } else if (stripeEvent.Type == Events.PaymentMethodAttached) { var paymentMethodEvent = stripeEvent.Data.Object as PaymentMethod; if (paymentMethodEvent != null) { var paymentMethodService = new PaymentMethodService(); var latestPaymentMethod = await paymentMethodService.GetAsync(paymentMethodEvent.Id, null, requestOptions); HandlePaymentMethodAttached(latestPaymentMethod, context); } } else { Console.WriteLine(\"Unhandled event type: {0}\", stripeEvent.Type); } return Ok(); } catch (StripeException e) { Console.WriteLine($\"Stripe error: {e.Message}\"); return BadRequest(); } } private void HandleCustomerCreated(Customer customer, string context) { Console.WriteLine($\"Handled customer {customer.Id} for context {context}\"); // Your custom logic here } private void HandlePaymentMethodAttached(PaymentMethod paymentMethod, string context) { Console.WriteLine($\"Handled payment method {paymentMethod.Id} for context {context}\"); // Your custom logic here } } } ``` #### Thin event handler (Clover+) Use the `EventNotification`’s `context` property to identify the account for events within your [organization](https://docs.stripe.com/get-started/account/orgs.md). You must set the [Stripe-Context header](https://docs.stripe.com/context.md) manually for all API calls except `.fetchRelatedObject()` and `.fetchEvent()`, which do this for you automatically. #### Python ```python org_api_key = os.environ.get(\"STRIPE_API_KEY\") webhook_secret = os.environ.get(\"WEBHOOK_SECRET\") client = StripeClient(org_api_key) # inside your webhook handler event_notification = client.parse_event_notification(payload, sig_header, webhook_secret) # uses `context` automatically event_notification.fetch_event() # pass context manually for other API requests client.v1.invoices.list(stripe_context=event_notification.context) ``` #### Ruby ```ruby api_key = ENV.fetch(\"STRIPE_API_KEY\", nil) webhook_secret = ENV.fetch(\"WEBHOOK_SECRET\", nil) client = Stripe::StripeClient.new(api_key) # inside your webhook handler event_notification = client.parse_event_notification(payload, sig_header, webhook_secret) # uses `context` automatically event_notification.fetch_event # pass context manually for other API requests client.v1.invoices.list(nil, { stripe_context: event_notification.context }) ``` #### Typescript ```typescript const orgApiKey = process.env.STRIPE_API_KEY; const webhookSecret = process.env.WEBHOOK_SECRET; const client = new Stripe(orgApiKey); // inside your webhook handler const eventNotification = client.parseEventNotification( req.body, sig, webhookSecret ); // uses `context` automatically: await eventNotification.fetchEvent() // pass context manually for other reuqests: client.invoices.list(undefined, { stripeContext: eventNotification.context, }); ``` #### Java ```java String orgApiKey = System.getenv(\"STRIPE_API_KEY\"); String webhookSecret = System.getenv(\"WEBHOOK_SECRET\"); StripeClient client = new StripeClient(orgApiKey); // inside your webhook handler EventNotification notif = client.parseEventNotification(webhookBody, sigHeader, WEBHOOK_SECRET); // cast to a more specific type V1BillingMeterErrorReportTriggeredEventNotification eventNotification = (V1BillingMeterErrorReportTriggeredEventNotification) notif; // uses `context` automatically eventNotification.fetchEvent(); // pass context manually for other API requests client .v1() .invoices() .list( new RequestOptions.RequestOptionsBuilder() .setStripeContext(eventNotification.context) .build()); ``` #### PHP ```php $org_api_key = getenv('STRIPE_API_KEY'); $webhook_secret = getenv('WEBHOOK_SECRET'); $client = new \\Stripe\\StripeClient($org_api_key); // inside your webhook handler $event_notification = $client->parseEventNotification($webhook_body, $sig_header, $webhook_secret); // uses context automatically $event_notification->fetchEvent(); // pass context manually for other API requests $client->invoices->all(null, [\"stripe_context\" => $event_notification->context]); ``` #### Go ```go orgApiKey := os.Getenv(\"STRIPE_API_KEY\") webhookSecret := os.Getenv(\"WEBHOOK_SECRET\") client := stripe.NewClient(orgApiKey) // inside your webhook handler eventNotification, err := client.ParseEventNotification(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret) if err != nil { fmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err) w.WriteHeader(http.StatusInternalServerError) return } // cast to a more specific type switch evt := eventNotification.(type) { case *stripe.V1BillingMeterErrorReportTriggeredEventNotification: // sets `Stripe-Context` automatically evt.FetchEvent(context.TODO()) // pass context manually for other API requests client.V1Invoices.Retrieve(context.TODO(), \"inv_123\", &stripe.InvoiceRetrieveParams{ Params: stripe.Params{ StripeContext: evt.Context.StringPtr(), }, }) } ``` #### .NET ```csharp _client = new StripeClient(Environment.GetEnvironmentVariable(\"STRIPE_API_KEY\")); _webhookSecret = Environment.GetEnvironmentVariable(\"WEBHOOK_SECRET\"); // inside your webhook handler var eventNotification = client.ParseEventNotification(json, Request.Headers[\"Stripe-Signature\"], webhookSecret); if (eventNotification is V1BillingMeterErrorReportTriggeredEventNotification notif) { // uses `context` automatically notif.fetchEvent(); // pass context manually for other API requests client.V1.Invoices.List(null, new RequestOptions { StripeContext = notif.Context, }); } ``` #### Thin event handler (Acacia or Basil) This code snippet is a webhook function configured to receive thin events across an organization, verify the signature, determine the originating account with the `context` field, and use that account’s API key for subsequent API calls. #### Python ```python import os from flask import Flask, request, jsonify from stripe import StripeClient from stripe.events import V1BillingMeterErrorReportTriggeredEvent app = Flask(__name__) org_api_key = os.environ.get(\"STRIPE_API_KEY\") webhook_secret = os.environ.get(\"WEBHOOK_SECRET\") client = StripeClient(org_api_key) account_api_keys = { \"account_123\": os.environ.get(\"ACCOUNT_123_API_KEY\"), \"account_456\": os.environ.get(\"ACCOUNT_456_API_KEY\"), } @app.route(\"/webhook\", methods=[\"POST\"]) def webhook(): payload = request.data sig_header = request.headers.get(\"Stripe-Signature\") try: thin_event = client.parse_thin_event(payload, sig_header, webhook_secret) # Retrieve the event using the org client to inspect context event = client.v2.core.events.retrieve(thin_event.id) context = getattr(event, \"context\", None) if not context: return jsonify(error=\"Missing context\"), 400 account_key = account_api_keys.get(context) if not account_key: return jsonify(error=\"Unknown context\"), 400 account_client = StripeClient(account_key) full_event = account_client.v2.core.events.retrieve(thin_event.id) if isinstance(full_event, V1BillingMeterErrorReportTriggeredEvent): meter = full_event.fetch_related_object() meter_id = meter.id # Record the failures and alert your team # Add your logic here return jsonify(success=True), 200 except Exception as e: return jsonify(error=str(e)), 400 if __name__ == \"__main__\": app.run(port=4242) ``` #### Ruby ```ruby require \"stripe\" require \"sinatra\" api_key = ENV.fetch(\"STRIPE_API_KEY\", nil) webhook_secret = ENV.fetch(\"WEBHOOK_SECRET\", nil) client = Stripe::StripeClient.new(api_key) account_api_keys = { \"account_123\" => ENV[\"ACCOUNT_123_API_KEY\"], \"account_456\" => ENV[\"ACCOUNT_456_API_KEY\"], } post \"/webhook\" do webhook_body = request.body.read sig_header = request.env[\"HTTP_STRIPE_SIGNATURE\"] begin thin_event = client.parse_thin_event(webhook_body, sig_header, webhook_secret) event = client.v2.core.events.retrieve(thin_event.id) context = event.context halt 400 if context.nil? account_key = account_api_keys[context] halt 400 if account_key.nil? account_client = Stripe::StripeClient.new(account_key) full_event = account_client.v2.core.events.retrieve(thin_event.id) if full_event.instance_of? Stripe::V1BillingMeterErrorReportTriggeredEvent meter = full_event.fetch_related_object # Record the failures and alert your team # Add your logic here end status 200 rescue => e status 400 end end ``` #### Node.js ```javascript const express = require('express'); const {Stripe} = require('stripe'); const app = express(); const apiKey = process.env.STRIPE_API_KEY; const webhookSecret = process.env.WEBHOOK_SECRET; const client = new Stripe(apiKey); const accountApiKeys = { account_123: process.env.ACCOUNT_123_API_KEY, account_456: process.env.ACCOUNT_456_API_KEY, }; app.post('/webhook', express.raw({type: 'application/json'}), async (req, res) => { const sig = req.headers['stripe-signature']; try { const thinEvent = client.parseThinEvent(req.body, sig, webhookSecret); const event = await client.v2.core.events.retrieve(thinEvent.id); const context = event.context; if (!context) return res.status(400).send('Missing context'); const accountKey = accountApiKeys[context]; if (!accountKey) return res.status(400).send('Unknown context'); const accountClient = new Stripe(accountKey); const fullEvent = await accountClient.v2.core.events.retrieve(thinEvent.id); if (fullEvent.type === 'v1.billing.meter.error_report_triggered') { const meter = await fullEvent.fetchRelatedObject(); // Record the failures and alert your team // Add your logic here } res.sendStatus(200); } catch (err) { res.status(400).send(`Webhook Error: ${err.message}`); } }); app.listen(4242); ``` #### Java ```java import com.stripe.StripeClient; import com.stripe.events.V1BillingMeterErrorReportTriggeredEvent; import com.stripe.model.Event; import com.stripe.model.ThinEvent; import java.util.HashMap; import java.util.Map; public Object handle(Request request, Response response) { String apiKey = System.getenv(\"STRIPE_API_KEY\"); String webhookSecret = System.getenv(\"WEBHOOK_SECRET\"); StripeClient client = new StripeClient(apiKey); Map accountApiKeys = new HashMap<>(); accountApiKeys.put(\"account_123\", System.getenv(\"ACCOUNT_123_API_KEY\")); accountApiKeys.put(\"account_456\", System.getenv(\"ACCOUNT_456_API_KEY\")); try { String webhookBody = request.body(); String sigHeader = request.headers(\"Stripe-Signature\"); ThinEvent thinEvent = client.parseThinEvent(webhookBody, sigHeader, webhookSecret); Event baseEvent = client.v2().core().events().retrieve(thinEvent.getId()); String context = baseEvent.getContext(); if (context == null || context.isEmpty()) { response.status(400); return \"\"; } String accountKey = accountApiKeys.get(context); if (accountKey == null || accountKey.isEmpty()) { response.status(400); return \"\"; } StripeClient accountClient = new StripeClient(accountKey); Event fullEvent = accountClient.v2().core().events().retrieve(thinEvent.getId()); if (fullEvent instanceof V1BillingMeterErrorReportTriggeredEvent) { V1BillingMeterErrorReportTriggeredEvent ev = (V1BillingMeterErrorReportTriggeredEvent) fullEvent; Object meter = ev.fetchRelatedObject(); // Record the failures and alert your team // Add your logic here } response.status(200); return \"\"; } catch (Exception e) { response.status(400); return \"\"; } } ``` #### PHP ```php getenv('ACCOUNT_123_API_KEY'), 'account_456' => getenv('ACCOUNT_456_API_KEY'), ]; $app = new \\Slim\\App(); $app->post('/webhook', function ($request, $response) use ($client, $webhook_secret, $accountApiKeys) { $webhook_body = $request->getBody()->getContents(); $sig_header = $request->getHeaderLine('Stripe-Signature'); try { $thin_event = $client->parseThinEvent($webhook_body, $sig_header, $webhook_secret); $event = $client->v2->core->events->retrieve($thin_event->id); $context = $event->context ?? null; if (!$context) return $response->withStatus(400); $accountKey = $accountApiKeys[$context] ?? null; if (!$accountKey) return $response->withStatus(400); $accountClient = new \\Stripe\\StripeClient($accountKey); $full_event = $accountClient->v2->core->events->retrieve($thin_event->id); if ($full_event instanceof \\Stripe\\\\Events\\\\V1BillingMeterErrorReportTriggeredEvent) { $meter = $full_event->fetchRelatedObject(); // Record the failures and alert your team // Add your logic here } return $response->withStatus(200); } catch (\\Exception $e) { return $response->withStatus(400); } }); $app->run(); ``` #### Go ```go package main import ( \"io\" \"log/slog\" \"net/http\" \"os\" \"github.com/stripe/stripe-go/v82\" ) func main() { apiKey := os.Getenv(\"STRIPE_API_KEY\") webhookSecret := os.Getenv(\"WEBHOOK_SECRET\") client := stripe.NewClient(apiKey) accountApiKeys := map[string]string{ \"account_123\": os.Getenv(\"ACCOUNT_123_API_KEY\"), \"account_456\": os.Getenv(\"ACCOUNT_456_API_KEY\"), } http.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) { defer req.Body.Close() payload, err := io.ReadAll(req.Body) if err != nil { slog.Error(\"read body\", \"error\", err) w.WriteHeader(http.StatusInternalServerError) return } thinEvent, err := client.ParseThinEvent(payload, req.Header.Get(\"Stripe-Signature\"), webhookSecret) if err != nil { w.WriteHeader(http.StatusBadRequest) return } baseEvent, err := client.V2.Core.Events.Retrieve(thinEvent.ID) if err != nil { w.WriteHeader(http.StatusInternalServerError) return } if baseEvent.Context == \"\" { w.WriteHeader(http.StatusBadRequest) return } accountKey, ok := accountApiKeys[baseEvent.Context] if !ok || accountKey == \"\" { w.WriteHeader(http.StatusBadRequest) return } accountClient := stripe.NewClient(accountKey) fullEvent, err := accountClient.V2.Core.Events.Retrieve(thinEvent.ID) if err != nil { w.WriteHeader(http.StatusInternalServerError) return } switch e := fullEvent.(type) { case *stripe.V1BillingMeterErrorReportTriggeredEvent: meter, err := e.FetchRelatedObject() if err == nil { _ = meter // Record the failures and alert your team // Add your logic here } } w.WriteHeader(http.StatusOK) }) http.ListenAndServe(\":4242\", nil) } ``` #### .NET ```csharp using Microsoft.AspNetCore.Mvc; using Stripe; [ApiController] [Route(\"/webhook\")] public class WebhookController : ControllerBase { private readonly StripeClient _client; private readonly string _webhookSecret; private readonly Dictionary _accountApiKeys; public WebhookController() { _client = new StripeClient(Environment.GetEnvironmentVariable(\"STRIPE_API_KEY\")); _webhookSecret = Environment.GetEnvironmentVariable(\"WEBHOOK_SECRET\"); _accountApiKeys = new Dictionary { { \"account_123\", Environment.GetEnvironmentVariable(\"ACCOUNT_123_API_KEY\") }, { \"account_456\", Environment.GetEnvironmentVariable(\"ACCOUNT_456_API_KEY\") }, }; } [HttpPost] public async Task Handle() { using var reader = new StreamReader(Request.Body); var json = await reader.ReadToEndAsync(); try { var thinEvent = _client.ParseThinEvent(json, Request.Headers[\"Stripe-Signature\"], _webhookSecret); var baseEvent = await _client.V2.Core.Events.GetAsync(thinEvent.Id); if (string.IsNullOrEmpty(baseEvent.Context)) { return BadRequest(); } if (!_accountApiKeys.TryGetValue(baseEvent.Context, out var accountKey) || string.IsNullOrEmpty(accountKey)) { return BadRequest(); } var accountClient = new StripeClient(accountKey); var fullEvent = await accountClient.V2.Core.Events.GetAsync(thinEvent.Id); if (fullEvent is V1BillingMeterErrorReportTriggeredEvent ev) { var meter = await ev.FetchRelatedObjectAsync(); // Record the failures and alert your team // Add your logic here } return Ok(); } catch { return BadRequest(); } } } ``` ## Test your handler Before you go-live with your webhook endpoint function, we recommend that you test your application integration. You can do so by configuring a local listener to send events to your local machine, and sending test events. You need to use the [CLI](https://docs.stripe.com/stripe-cli.md) to test. #### Forward events to a local endpoint To forward events to your local endpoint, run the following command with the [CLI](https://docs.stripe.com/stripe-cli.md) to set up a local listener. The `--forward-to` flag sends all [Stripe events](https://docs.stripe.com/cli/trigger#trigger-event) in a [sandbox](https://docs.stripe.com/sandboxes.md) to your local webhook endpoint. Use the appropriate CLI commands below depending on whether you use [thin](https://docs.stripe.com/event-destinations.md#events-overview) or snapshot events. #### Forward snapshot events Use the following command to forward [snapshot events](https://docs.stripe.com/event-destinations.md#events-overview) to your local listener. ```bash stripe listen --forward-to localhost:4242 ``` #### Forward thin events Use the following command to forward [thin events](https://docs.stripe.com/event-destinations.md#events-overview) to your local listener. ```bash $ stripe listen --forward-thin-to localhost:4242 --thin-events \"*\" ``` > You can also run `stripe listen` to see events in [Stripe Shell](https://docs.stripe.com/stripe-shell/overview.md), although you won’t be able to forward events from the shell to your local endpoint. Useful configurations to help you test with your local listener include the following: - To disable HTTPS certificate verification, use the `--skip-verify` optional flag. - To forward only specific events, use the `--events` optional flag and pass in a comma separated list of events. #### Forward target snapshot events Use the following command to forward target snapshot events to your local listener. ```bash stripe listen --events payment_intent.created,customer.created,payment_intent.succeeded,checkout.session.completed,payment_intent.payment_failed \\ --forward-to localhost:4242 ``` #### Forward target thin events Use the following command to forward target thin events to your local listener. ```bash stripe listen --thin-events v1.billing.meter.error_report_triggered,v1.billing.meter.no_meter_found \\ --forward-thin-to localhost:4242 ``` - To forward events to your local webhook endpoint from the public webhook endpoint that you already registered on Stripe, use the `--load-from-webhooks-api` optional flag. It loads your registered endpoint, parses the path and its registered events, then appends the path to your local webhook endpoint in the `--forward-to path`. #### Forward snapshot events from a public webhook endpoint Use the following command to forward snapshot events from a public webhook endpoint to your local listener. ```bash stripe listen --load-from-webhooks-api --forward-to localhost:4242 ``` #### Forward thin events from a public webhook endpoint Use the following command to forward thin events from a public webhook endpoint to your local listener. ```bash stripe listen --load-from-webhooks-api --forward-thin-to localhost:4242 ``` - To check webhook signatures, use the `{{WEBHOOK_SIGNING_SECRET}}` from the initial output of the listen command. ```output Ready! Your webhook signing secret is '{{WEBHOOK_SIGNING_SECRET}}' (^C to quit) ``` #### Triggering test events To send test events, trigger an event type that your event destination is subscribed to by manually creating an object in the Stripe Dashboard. Learn how to trigger events with [Stripe for VS Code](https://docs.stripe.com/stripe-vscode.md). #### Trigger a snapshot event You can use the following command in either [Stripe Shell](https://docs.stripe.com/stripe-shell/overview.md) or [Stripe CLI](https://docs.stripe.com/stripe-cli.md). This example triggers a `payment_intent.succeeded` event: ```bash stripe trigger payment_intent.succeeded Running fixture for: payment_intent Trigger succeeded! Check dashboard for event details. ``` #### Trigger a thin event You can use the following command in the [Stripe CLI](https://docs.stripe.com/stripe-cli.md). This example triggers a `outbound_payment.posted` event: ```bash stripe preview trigger outbound_payment.posted Setting up fixture for: finaddr_info Running fixture for: finaddr_info Setting up fixture for: create_recipient Running fixture for: create_recipient Setting up fixture for: create_destination Running fixture for: create_destination Setting up fixture for: create_outbound_payment Running fixture for: create_outbound_payment ``` ## Register your endpoint After testing your webhook endpoint function, use the [API](https://docs.stripe.com/api/v2/event-destinations.md) or the **Webhooks** tab in Workbench to register your webhook endpoint’s accessible URL so Stripe knows where to deliver events. You can register up to 16 webhook endpoints with Stripe. Registered webhook endpoints must be publicly accessible **HTTPS** URLs. #### Webhook URL format The URL format to register a webhook endpoint is: ``` https:/// ``` For example, if your domain is `https://mycompanysite.com` and the route to your webhook endpoint is `@app.route('/stripe_webhooks', methods=['POST'])`, specify `https://mycompanysite.com/stripe_webhooks` as the **Endpoint URL**. #### Create an event destination for your webhook endpoint Create an event destination using Workbench in the Dashboard or programmatically with the [API](https://docs.stripe.com/api/v2/event-destinations.md). You can register up to 16 event destinations on each Stripe account. #### Dashboard To create a new webhook endpoint in the Dashboard: 1. Open the [Webhooks](https://dashboard.stripe.com/webhooks) tab in Workbench. 1. Click **Create an event destination**. 1. Select where you want to receive events from. Stripe supports two types of configurations: **Your account** and [Connected accounts](https://docs.stripe.com/connect.md). Select **Account** to listen to events from your own account. If you created a [Connect application](https://docs.stripe.com/connect.md) and want to listen to events from your connected accounts, select **Connected accounts**. > #### Listen to events from an organization webhook endpoint > > If you create a webhook endpoint in an [organization account](https://docs.stripe.com/get-started/account/orgs.md), select **Accounts** to listen to events from accounts in your organization. If you have [Connect platforms](https://docs.stripe.com/connect.md) as members of your organizations and want to listen to events from the all the platforms’ connected accounts, select **Connected accounts**. 1. Select the API version for the [events object](https://docs.stripe.com/api/events.md) you want to consume. 1. Select the [event types](https://docs.stripe.com/api/events/types.md) that you want to send to a webhook endpoint. 1. Select **Continue**, then select **Webhook endpoint** as the destination type. 1. Click **Continue**, then provide the **Endpoint URL** and an optional description for the webhook. ![Register a new webhook using the Webhooks tab](https://b.stripecdn.com/docs-statics-srv/assets/create-webhook.f728025897e9e4ca2ba623abe34995a0.png) Register a new webhook using the **Webhooks** tab #### API You can create a new event destination that notifies you when a [usage-based billing](https://docs.stripe.com/billing/subscriptions/usage-based.md) validation error is triggered using the [API](https://docs.stripe.com/api/v2/event-destinations.md). If you’ve created a [Connect application](https://docs.stripe.com/connect.md) and want to listen to your connected accounts, use the [events_from](https://docs.stripe.com/api/v2/event-destinations/create.md#v2_create_event_destinations-events_from) parameter and set its enum value to `accounts`. ```curl curl -X POST https://api.stripe.com/v2/core/event_destinations \\ -H \"Authorization: Bearer <>\" \\ -H \"Stripe-Version: 2025-09-30.preview\" \\ --json '{ \"name\": \"My event destination\", \"description\": \"This is my event destination, I like it a lot\", \"type\": \"webhook_endpoint\", \"event_payload\": \"thin\", \"enabled_events\": [ \"v1.billing.meter.error_report_triggered\" ], \"webhook_endpoint\": { \"url\": \"https://example.com/my/webhook/endpoint\" } }' ``` ```cli stripe preview v2 core event_destinations create \\ --name=\"My event destination\" \\ --description=\"This is my event destination, I like it a lot\" \\ --type=webhook_endpoint \\ --event-payload=thin \\ --enabled-events=\"v1.billing.meter.error_report_triggered\" \\ --webhook-endpoint.url=\"https://example.com/my/webhook/endpoint\" ``` ```ruby # See your keys here: https://dashboard.stripe.com/apikeys client = Stripe::StripeClient.new(\"<>\") event_destination = client.v2.core.event_destinations.create({ name: 'My event destination', description: 'This is my event destination, I like it a lot', type: 'webhook_endpoint', event_payload: 'thin', enabled_events: ['v1.billing.meter.error_report_triggered'], webhook_endpoint: {url: 'https://example.com/my/webhook/endpoint'}, }) ``` ```python # See your keys here: https://dashboard.stripe.com/apikeys client = StripeClient(\"<>\") event_destination = client.v2.core.event_destinations.create({ \"name\": \"My event destination\", \"description\": \"This is my event destination, I like it a lot\", \"type\": \"webhook_endpoint\", \"event_payload\": \"thin\", \"enabled_events\": [\"v1.billing.meter.error_report_triggered\"], \"webhook_endpoint\": {\"url\": \"https://example.com/my/webhook/endpoint\"}, }) ``` ```php // See your keys here: https://dashboard.stripe.com/apikeys $stripe = new \\Stripe\\StripeClient('<>'); $eventDestination = $stripe->v2->core->eventDestinations->create([ 'name' => 'My event destination', 'description' => 'This is my event destination, I like it a lot', 'type' => 'webhook_endpoint', 'event_payload' => 'thin', 'enabled_events' => ['v1.billing.meter.error_report_triggered'], 'webhook_endpoint' => ['url' => 'https://example.com/my/webhook/endpoint'], ]); ``` ```java // See your keys here: https://dashboard.stripe.com/apikeys StripeClient client = new StripeClient(\"<>\"); EventDestinationCreateParams params = EventDestinationCreateParams.builder() .setName(\"My event destination\") .setDescription(\"This is my event destination, I like it a lot\") .setType(EventDestinationCreateParams.Type.WEBHOOK_ENDPOINT) .setEventPayload(EventDestinationCreateParams.EventPayload.THIN) .addEnabledEvent(\"v1.billing.meter.error_report_triggered\") .setWebhookEndpoint( EventDestinationCreateParams.WebhookEndpoint.builder() .setUrl(\"https://example.com/my/webhook/endpoint\") .build() ) .build(); EventDestination eventDestination = client.v2().core().eventDestinations().create(params); ``` ```node // See your keys here: https://dashboard.stripe.com/apikeys const stripe = require('stripe')('<>'); const eventDestination = await stripe.v2.core.eventDestinations.create({ name: 'My event destination', description: 'This is my event destination, I like it a lot', type: 'webhook_endpoint', event_payload: 'thin', enabled_events: ['v1.billing.meter.error_report_triggered'], webhook_endpoint: { url: 'https://example.com/my/webhook/endpoint', }, }); ``` ```go // See your keys here: https://dashboard.stripe.com/apikeys sc := stripe.NewClient(\"<>\") params := &stripe.V2CoreEventDestinationCreateParams{ Name: stripe.String(\"My event destination\"), Description: stripe.String(\"This is my event destination, I like it a lot\"), Type: stripe.String(\"webhook_endpoint\"), EventPayload: stripe.String(\"thin\"), EnabledEvents: []*string{stripe.String(\"v1.billing.meter.error_report_triggered\")}, WebhookEndpoint: &stripe.V2CoreEventDestinationCreateWebhookEndpointParams{ URL: stripe.String(\"https://example.com/my/webhook/endpoint\"), }, } result, err := sc.V2CoreEventDestinations.Create(context.TODO(), params) ``` ```dotnet // See your keys here: https://dashboard.stripe.com/apikeys var options = new Stripe.V2.Core.EventDestinationCreateOptions { Name = \"My event destination\", Description = \"This is my event destination, I like it a lot\", Type = \"webhook_endpoint\", EventPayload = \"thin\", EnabledEvents = new List { \"v1.billing.meter.error_report_triggered\" }, WebhookEndpoint = new Stripe.V2.Core.EventDestinationCreateWebhookEndpointOptions { Url = \"https://example.com/my/webhook/endpoint\", }, }; var client = new StripeClient(\"<>\"); var service = client.V2.Core.EventDestinations; Stripe.V2.Core.EventDestination eventDestination = service.Create(options); ``` > [Workbench](https://docs.stripe.com/workbench.md) replaces the existing [Developers Dashboard](https://docs.stripe.com/development/dashboard.md). If you’re still using the Developers Dashboard, see how to [create a new webhook endpoint](https://docs.stripe.com/development/dashboard/webhooks.md). ## Secure your endpoint After confirming that your endpoint works as expected, secure it by implementing [webhook best practices](https://docs.stripe.com/webhooks.md#best-practices). You need to secure your integration by making sure your handler verifies that all webhook requests are generated by Stripe. You can verify webhook signatures using our official libraries or verify them manually. #### Verify with official libraries (recommended) ### Verify webhook signatures with official libraries We recommend using our official libraries to verify signatures. You perform the verification by providing the event payload, the `Stripe-Signature` header, and the endpoint’s secret. If verification fails, you get an error. If you get a signature verification error, read our guide about [troubleshooting it](https://docs.stripe.com/webhooks/signature.md). > Stripe requires the raw body of the request to perform signature verification. If you’re using a framework, make sure it doesn’t manipulate the raw body. Any manipulation to the raw body of the request causes the verification to fail. #### Ruby ```ruby # Set your secret key. Remember to switch to your live secret key in production. # See your keys here: https://dashboard.stripe.com/apikeys Stripe.api_key = '<>' require 'stripe' require 'sinatra' # If you are testing your webhook locally with the Stripe CLI you # can find the endpoint's secret by running `stripe listen` # Otherwise, find your endpoint's secret in your webhook settings in # the Developer Dashboardendpoint_secret = 'whsec_...' # Using the Sinatra framework set :port, 4242 post '/my/webhook/url' do payload = request.body.readsig_header = request.env['HTTP_STRIPE_SIGNATURE'] event = nil beginevent = Stripe::Webhook.construct_event( payload, sig_header, endpoint_secret ) rescue JSON::ParserError => e # Invalid payload puts \"Error parsing payload: #{e.message}\" status 400 return rescue Stripe::SignatureVerificationError => e# Invalid signature puts \"Error verifying webhook signature: #{e.message}\" status 400 return end # Handle the event case event.type when 'payment_intent.succeeded' payment_intent = event.data.object # contains a Stripe::PaymentIntent puts 'PaymentIntent was successful!' when 'payment_method.attached' payment_method = event.data.object # contains a Stripe::PaymentMethod puts 'PaymentMethod was attached to a Customer!' # ... handle other event types else puts \"Unhandled event type: #{event.type}\" end status 200 end ``` #### Python ```python # Set your secret key. Remember to switch to your live secret key in production. # See your keys here: https://dashboard.stripe.com/apikeys stripe.api_key = '<>' from django.http import HttpResponse # If you are testing your webhook locally with the Stripe CLI you # can find the endpoint's secret by running `stripe listen` # Otherwise, find your endpoint's secret in your webhook settings in the Developer Dashboardendpoint_secret = 'whsec_...' # Using Django @csrf_exempt def my_webhook_view(request): payload = request.bodysig_header = request.META['HTTP_STRIPE_SIGNATURE'] event = None try:event = stripe.Webhook.construct_event( payload, sig_header, endpoint_secret ) except ValueError as e: # Invalid payload print('Error parsing payload: {}'.format(str(e))) return HttpResponse(status=400)except stripe.error.SignatureVerificationError as e: # Invalid signature print('Error verifying webhook signature: {}'.format(str(e))) return HttpResponse(status=400) # Handle the event if event.type == 'payment_intent.succeeded': payment_intent = event.data.object # contains a stripe.PaymentIntent print('PaymentIntent was successful!') elif event.type == 'payment_method.attached': payment_method = event.data.object # contains a stripe.PaymentMethod print('PaymentMethod was attached to a Customer!') # ... handle other event types else: print('Unhandled event type {}'.format(event.type)) return HttpResponse(status=200) ``` #### PHP ```php // Set your secret key. Remember to switch to your live secret key in production. // See your keys here: https://dashboard.stripe.com/apikeys \\Stripe\\Stripe::setApiKey('<>'); // If you are testing your webhook locally with the Stripe CLI you // can find the endpoint's secret by running `stripe listen` // Otherwise, find your endpoint's secret in your webhook settings in the Developer Dashboard$endpoint_secret = 'whsec_...'; $payload = @file_get_contents('php://input'); $sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE']; $event = null; try {$event = \\Stripe\\Webhook::constructEvent( $payload, $sig_header, $endpoint_secret ); } catch(\\UnexpectedValueException $e) { // Invalid payload http_response_code(400); echo json_encode(['Error parsing payload: ' => $e->getMessage()]); exit();} catch(\\Stripe\\Exception\\SignatureVerificationException $e) { // Invalid signature http_response_code(400); echo json_encode(['Error verifying webhook signature: ' => $e->getMessage()]); exit(); } // Handle the event switch ($event->type) { case 'payment_intent.succeeded': $paymentIntent = $event->data->object; // contains a \\Stripe\\PaymentIntent handlePaymentIntentSucceeded($paymentIntent); break; case 'payment_method.attached': $paymentMethod = $event->data->object; // contains a \\Stripe\\PaymentMethod handlePaymentMethodAttached($paymentMethod); break; // ... handle other event types default: echo 'Received unknown event type ' . $event->type; } http_response_code(200); ``` #### Java ```java // Set your secret key. Remember to switch to your live secret key in production. // See your keys here: https://dashboard.stripe.com/apikeys Stripe.apiKey = \"<>\"; import com.stripe.Stripe; import com.stripe.model.StripeObject; import com.stripe.net.ApiResource; import com.stripe.net.Webhook; import com.stripe.model.Event; import com.stripe.model.EventDataObjectDeserializer; import com.stripe.model.PaymentIntent; import com.stripe.exception.SignatureVerificationException; // If you are testing your webhook locally with the Stripe CLI you // can find the endpoint's secret by running `stripe listen` // Otherwise, find your endpoint's secret in your webhook settings in the Developer DashboardString endpointSecret = \"whsec_...\"; // Using the Spark framework public Object handle(Request request, Response response) { String payload = request.body();String sigHeader = request.headers(\"Stripe-Signature\"); Event event = null; try {event = Webhook.constructEvent( payload, sigHeader, endpointSecret ); } catch (JsonSyntaxException e) { // Invalid payload System.out.println(\"Error parsing payload: \" + e.getMessage()); response.status(400); return gson.toJson(new ErrorResponse(e.getMessage()));} catch (SignatureVerificationException e) { // Invalid signature System.out.println(\"Error verifying webhook signature: \" + e.getMessage()); response.status(400); return gson.toJson(new ErrorResponse(e.getMessage())); } // Deserialize the nested object inside the event EventDataObjectDeserializer dataObjectDeserializer = event.getDataObjectDeserializer(); StripeObject stripeObject = null; if (dataObjectDeserializer.getObject().isPresent()) { stripeObject = dataObjectDeserializer.getObject().get(); } else { // Deserialization failed, probably due to an API version mismatch. // Refer to the Javadoc documentation on `EventDataObjectDeserializer` for // instructions on how to handle this case, or return an error here. } // Handle the event switch (event.getType()) { case \"payment_intent.succeeded\": PaymentIntent paymentIntent = (PaymentIntent) stripeObject; System.out.println(\"PaymentIntent was successful!\"); break; case \"payment_method.attached\": PaymentMethod paymentMethod = (PaymentMethod) stripeObject; System.out.println(\"PaymentMethod was attached to a Customer!\"); break; // ... handle other event types default: System.out.println(\"Unhandled event type: \" + event.getType()); } response.status(200); return \"\"; } ``` #### Node.js ```javascript // Set your secret key. Remember to switch to your live secret key in production. // See your keys here: https://dashboard.stripe.com/apikeys const stripe = require('stripe')('<>'); // If you are testing your webhook locally with the Stripe CLI you // can find the endpoint's secret by running `stripe listen` // Otherwise, find your endpoint's secret in your webhook settings in the Developer Dashboardconst endpointSecret = 'whsec_...'; // This example uses Express to receive webhooks const express = require('express'); const app = express(); // Match the raw body to content type application/json app.post('/webhook', express.raw({type: 'application/json'}), (request, response) => {const sig = request.headers['stripe-signature']; let event; try {event = stripe.webhooks.constructEvent(request.body, sig, endpointSecret); }catch (err) { response.status(400).send(`Webhook Error: ${err.message}`); } // Handle the event switch (event.type) { case 'payment_intent.succeeded': const paymentIntent = event.data.object; console.log('PaymentIntent was successful!'); break; case 'payment_method.attached': const paymentMethod = event.data.object; console.log('PaymentMethod was attached to a Customer!'); break; // ... handle other event types default: console.log(`Unhandled event type ${event.type}`); } // Return a response to acknowledge receipt of the event response.json({received: true}); }); app.listen(4242, () => console.log('Running on port 4242')); ``` #### Go ```go // Set your secret key. Remember to switch to your live secret key in production. // See your keys here: https://dashboard.stripe.com/apikeys stripe.Key = \"<>\" http.HandleFunc(\"/webhook\", func(w http.ResponseWriter, req *http.Request) { const MaxBodyBytes = int64(65536) req.Body = http.MaxBytesReader(w, req.Body, MaxBodyBytes) payload, err := ioutil.ReadAll(req.Body) if err != nil { fmt.Fprintf(os.Stderr, \"Error reading request body: %v\\n\", err) w.WriteHeader(http.StatusServiceUnavailable) return } // If you are testing your webhook locally with the Stripe CLI you // can find the endpoint's secret by running `stripe listen` // Otherwise, find your endpoint's secret in your webhook settings // in the Developer DashboardendpointSecret := \"whsec_...\"; // Pass the request body and Stripe-Signature header to ConstructEvent, along // with the webhook signing key.event, err := webhook.ConstructEvent(payload, req.Header.Get(\"Stripe-Signature\"), endpointSecret) if err != nil { fmt.Fprintf(os.Stderr, \"Error verifying webhook signature: %v\\n\", err) w.WriteHeader(http.StatusBadRequest) // Return a 400 error on a bad signature return } // Unmarshal the event data into an appropriate struct depending on its Type switch event.Type { case \"payment_intent.succeeded\": var paymentIntent stripe.PaymentIntent err := json.Unmarshal(event.Data.Raw, &paymentIntent) if err != nil { fmt.Fprintf(os.Stderr, \"Error parsing webhook JSON: %v\\n\", err) w.WriteHeader(http.StatusBadRequest) return } fmt.Println(\"PaymentIntent was successful!\") case \"payment_method.attached\": var paymentMethod stripe.PaymentMethod err := json.Unmarshal(event.Data.Raw, &paymentMethod) if err != nil { fmt.Fprintf(os.Stderr, \"Error parsing webhook JSON: %v\\n\", err) w.WriteHeader(http.StatusBadRequest) return } fmt.Println(\"PaymentMethod was attached to a Customer!\") // ... handle other event types default: fmt.Fprintf(os.Stderr, \"Unhandled event type: %s\\n\", event.Type) } w.WriteHeader(http.StatusOK) }) ``` #### .NET ```dotnet // Set your secret key. Remember to switch to your live secret key in production. // See your keys here: https://dashboard.stripe.com/apikeys StripeConfiguration.ApiKey = \"<>\"; using System; using System.IO; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Stripe; namespace workspace.Controllers { [Route(\"api/[controller]\")] public class StripeWebHook : Controller { // If you are testing your webhook locally with the Stripe CLI you // can find the endpoint's secret by running `stripe listen` // Otherwise, find your endpoint's secret in your webhook settings // in the Developer Dashboardconst string endpointSecret = \"whsec_...\"; [HttpPost] public async Task Index() { var json = await new StreamReader(HttpContext.Request.Body).ReadToEndAsync(); try {var stripeEvent = EventUtility.ConstructEvent(json, Request.Headers[\"Stripe-Signature\"], endpointSecret); // Handle the event // If on SDK version < 46, use class Events instead of EventTypes if (stripeEvent.Type == EventTypes.PaymentIntentSucceeded) { var paymentIntent = stripeEvent.Data.Object as PaymentIntent; Console.WriteLine(\"PaymentIntent was successful!\"); } else if (stripeEvent.Type == EventTypes.PaymentMethodAttached) { var paymentMethod = stripeEvent.Data.Object as PaymentMethod; Console.WriteLine(\"PaymentMethod was attached to a Customer!\"); } // ... handle other event types else { Console.WriteLine(\"Unhandled event type: {0}\", stripeEvent.Type); } return Ok(); }catch (StripeException e) { return BadRequest(e.Message); } } } } ``` #### Verify manually ### Verify webhook signatures manually Although we recommend that you use our official libraries to verify webhook event signatures, you can create a custom solution by following this section. The `Stripe-Signature` header included in each signed event contains a timestamp and one or more signatures that you must verify. The timestamp has a `t=` prefix, and each signature has a *scheme* prefix. Schemes start with `v`, followed by an integer. Currently, the only valid live signature scheme is `v1`. To aid with testing, Stripe sends an additional signature with a fake `v0` scheme, for test events. ``` Stripe-Signature: t=1492774577, v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd, v0=6ffbb59b2300aae63f272406069a9788598b792a944a07aba816edb039989a39 ``` > We provide newlines for clarity, but a real `Stripe-Signature` header is on a single line. Stripe generates signatures using a hash-based message authentication code ([HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code)) with [SHA-256](https://en.wikipedia.org/wiki/SHA-2). To prevent [downgrade attacks](https://en.wikipedia.org/wiki/Downgrade_attack), ignore all schemes that aren’t `v1`. You can have multiple signatures with the same scheme-secret pair when you [roll an endpoint’s secret](https://docs.stripe.com/webhooks.md#roll-endpoint-secrets), and keep the previous secret active for up to 24 hours. During this time, your endpoint has multiple active secrets and Stripe generates one signature for each secret. To create a manual solution for verifying signatures, you must complete the following steps: #### Step 1: Extract the timestamp and signatures from the header Split the header using the `,` character as the separator to get a list of elements. Then split each element using the `=` character as the separator to get a prefix and value pair. The value for the prefix `t` corresponds to the timestamp, and `v1` corresponds to the signature (or signatures). You can discard all other elements. #### Step 2: Prepare the `signed_payload` string The `signed_payload` string is created by concatenating: - The timestamp (as a string) - The character `.` - The actual JSON payload (that is, the request body) #### Step 3: Determine the expected signature Compute an HMAC with the SHA256 hash function. Use the endpoint’s signing secret as the key, and use the `signed_payload` string as the message. #### Step 4: Compare the signatures Compare the signature (or signatures) in the header to the expected signature. For an equality match, compute the difference between the current timestamp and the received timestamp, then decide if the difference is within your tolerance. To protect against timing attacks, use a constant-time-string comparison to compare the expected signature to each of the received signatures. ## Debug webhook integrations Multiple types of issues can occur when delivering events to your webhook endpoint: - Stripe might not be able to deliver an event to your webhook endpoint. - Your webhook endpoint might have an SSL issue. - Your network connectivity is intermittent. - Your webhook endpoint isn’t receiving events that you expect to receive. ### View event deliveries You can also use the [Stripe CLI](https://docs.stripe.com/stripe-cli.md) to [listen for events](https://docs.stripe.com/webhooks.md#test-webhook) directly in your terminal. To view event deliveries, select the webhook endpoint under **Webhooks**, then select the **Events** tab. The **Events** tab provides a list of events and whether they’re `Delivered`, `Pending`, or `Failed`. Click an event to view metadata, including the HTTP status code of the delivery attempt and the time of pending future deliveries. ### Fix HTTP status codes When an event displays a status code of `200`, it indicates successful delivery to the webhook endpoint. You might also receive a status code other than `200`. View the table below for a list of common HTTP status codes and recommended solutions. | Pending webhook status | Description | Fix | | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- | | (Unable to connect) ERR | We’re unable to establish a connection to the destination server. | Make sure that your host domain is publicly accessible to the internet. | | (`302`) ERR (or other `3xx` status) | The destination server attempted to redirect the request to another location. We consider redirect responses to webhook requests as failures. | Set the webhook endpoint destination to the URL resolved by the redirect. | | (`400`) ERR (or other `4xx` status) | The destination server can’t or won’t process the request. This might occur when the server detects an error (`400`), when the destination URL has access restrictions, (`401`, `403`), or when the destination URL doesn’t exist (`404`). | - Make sure that your endpoint is publicly accessible to the internet. - Make sure that your endpoint accepts a POST HTTP method. | | (`500`) ERR (or other `5xx` status) | The destination server encountered an error while processing the request. | Review your application’s logs to understand why it’s returning a `500` error. | | (TLS error) ERR | We couldn’t establish a secure connection to the destination server. Issues with the SSL/TLS certificate or an intermediate certificate in the destination server’s certificate chain usually cause these errors. Stripe requires *TLS* (TLS refers to the process of securely transmitting data between the client—the app or browser that your customer is using—and your server. This was originally performed using the SSL (Secure Sockets Layer) protocol) version `v1.2` or higher. | Perform an [SSL server test](https://www.ssllabs.com/ssltest/) to find issues that might cause this error. | | (Timed out) ERR | The destination server took too long to respond to the webhook request. | Make sure you defer complex logic and return a successful response immediately in your webhook handling code. | ## Event delivery behaviors This section helps you understand different behaviors to expect regarding how Stripe sends events to your webhook endpoint. ### Automatic retries Stripe attempts to deliver events to your destination for up to three days with an exponential back off in live mode. View when the next retry will occur, if applicable, in your event destination’s **Event deliveries** tab. We retry event deliveries created in a sandbox three times over the course of a few hours. If your destination has been disabled or deleted when we attempt a retry, we prevent future retries of that event. However, if you disable and then re-enable the event destination before we’re able to retry, you still see future retry attempts. ### Manual retries There are two ways to manually retry events: - In the Stripe Dashboard, click **Resend** when looking at a specific event. This works for up to 15 days after the event creation. - With the [Stripe CLI](https://docs.stripe.com/cli/events/resend), run the `stripe events resend --webhook-endpoint=` command. This works for up to 30 days after the event creation. Manually resending an event that had previous delivery failures to a webhook endpoint doesn’t dismiss Stripe’s [automatic retry behavior](https://docs.stripe.com/webhooks.md#automatic-retries). Automatic retries still happen until you respond to one of them with a `2xx` status code. ### Event ordering Stripe doesn’t guarantee the delivery of events in the order that they’re generated. For example, creating a subscription might generate the following events: - `customer.subscription.created` - `invoice.created` - `invoice.paid` - `charge.created` (if there’s a charge) Make sure that your event destination isn’t dependent on receiving events in a specific order. Be prepared to manage their delivery appropriately. You can also use the API to retrieve any missing objects. For example, you can retrieve the invoice, charge, and subscription objects with the information from `invoice.paid` if you receive this event first. ### API versioning The API version in your account settings when the event occurs dictates the API version, and therefore the structure of an [Event](https://docs.stripe.com/api/events.md) sent to your destination. For example, if your account is set to an older API version, such as 2015-02-16, and you change the API version for a specific request with [versioning](https://docs.stripe.com/api.md#versioning), the [Event](https://docs.stripe.com/api/events.md) object generated and sent to your destination is still based on the 2015-02-16 API version. You can’t change [Event](https://docs.stripe.com/api/events.md) objects after creation. For example, if you update a charge, the original charge event remains unchanged. As a result, subsequent updates to your account’s API version don’t retroactively alter existing [Event](https://docs.stripe.com/api/events.md) objects. Retrieving an older [Event](https://docs.stripe.com/api/events.md) by calling `/v1/events` using a newer API version also has no impact on the structure of the received event. You can set test event destinations to either your default API version or the latest API version. The [Event](https://docs.stripe.com/api/events.md) sent to the destination is structured for the event destination’s specified version. ## Best practices for using webhooks Review these best practices to make sure your webhook endpoints remain secure and function well with your integration. ### Handle duplicate events Webhook endpoints might occasionally receive the same event more than once. You can guard against duplicated event receipts by logging the [event IDs](https://docs.stripe.com/api/events/object.md#event_object-id) you’ve processed, and then not processing already-logged events. In some cases, two separate Event objects are generated and sent. To identify these duplicates, use the ID of the object in `data.object` along with the `event.type`. ### Only listen to event types your integration requires Configure your webhook endpoints to receive only the types of events required by your integration. Listening for extra events (or all events) puts undue strain on your server and we don’t recommend it. You can [change the events](https://docs.stripe.com/api/webhook_endpoints/update.md#update_webhook_endpoint-enabled_events) that a webhook endpoint receives in the Dashboard or with the API. ### Handle events asynchronously Configure your handler to process incoming events with an asynchronous queue. You might encounter scalability issues if you choose to process events synchronously. Any large spike in webhook deliveries (for example, during the beginning of the month when all subscriptions renew) might overwhelm your endpoint hosts. Asynchronous queues allow you to process the concurrent events at a rate your system can support. ### Exempt webhook route from CSRF protection If you’re using Rails, Django, or another web framework, your site might automatically check that every POST request contains a *CSRF token*. This is an important security feature that helps protect you and your users from [cross-site request forgery](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_\\(CSRF\\)) attempts. However, this security measure might also prevent your site from processing legitimate events. If so, you might need to exempt the webhooks route from CSRF protection. #### Rails ```ruby class StripeController < ApplicationController # If your controller accepts requests other than Stripe webhooks, # you'll probably want to use `protect_from_forgery` to add CSRF # protection for your application. But don't forget to exempt # your webhook route! protect_from_forgery except: :webhook def webhook # Process webhook data in `params` end end ``` #### Django ```python import json # Webhooks are always sent as HTTP POST requests, so ensure # that only POST requests reach your webhook view by # decorating `webhook()` with `require_POST`. # # To ensure that the webhook view can receive webhooks, # also decorate `webhook()` with `csrf_exempt`. @require_POST @csrf_exempt def webhook(request): # Process webhook data in `request.body` ``` ### Receive events with an HTTPS server If you use an HTTPS URL for your webhook endpoint (required in live mode), Stripe validates that the connection to your server is secure before sending your webhook data. For this to work, your server must be correctly configured to support HTTPS with a valid server certificate. Stripe webhooks support only *TLS* (TLS refers to the process of securely transmitting data between the client—the app or browser that your customer is using—and your server. This was originally performed using the SSL (Secure Sockets Layer) protocol) versions v1.2 and v1.3. ### Roll endpoint signing secrets periodically The secret used for verifying that events come from Stripe is modifiable in the **Webhooks** tab in Workbench. To keep them safe, we recommend that you roll (change) secrets periodically, or when you suspect a compromised secret. To roll a secret: 1. Click each endpoint in the Workbench **Webhooks** tab that you want to roll the secret for. 1. Navigate to the overflow menu (⋯) and click **Roll secret**. You can choose to immediately expire the current secret or delay its expiration for up to 24 hours to allow yourself time to update the verification code on your server. During this time, multiple secrets are active for the endpoint. Stripe generates one signature per secret until expiration. ### Verify events are sent from Stripe Stripe sends webhook events from a set list of IP addresses. Only trust events coming from these [IP addresses](https://docs.stripe.com/ips.md). Also verify webhook signatures to confirm that Stripe sent the received events. Stripe signs webhook events it sends to your endpoints by including a signature in each event’s `Stripe-Signature` header. This allows you to verify that the events were sent by Stripe, not by a third party. You can verify signatures either using our [official libraries](https://docs.stripe.com/webhooks.md#verify-official-libraries), or [verify manually](https://docs.stripe.com/webhooks.md#verify-manually) using your own solution. The following section describes how to verify webhook signatures: 1. Retrieve your endpoint’s secret. 1. Verify the signature. #### Retrieving your endpoint’s secret Use Workbench and go to the **Webhooks** tab to view all your endpoints. Select an endpoint that you want to obtain the secret for, then click **Click to reveal**. Stripe generates a unique secret key for each endpoint. If you use the same endpoint for both [test and live API keys](https://docs.stripe.com/keys.md#test-live-modes), the secret is different for each one. Additionally, if you use multiple endpoints, you must obtain a secret for each one you want to verify signatures on. After this setup, Stripe starts to sign each webhook it sends to the endpoint. ### Preventing replay attacks A [replay attack](https://en.wikipedia.org/wiki/Replay_attack) is when an attacker intercepts a valid payload and its signature, then re-transmits them. To mitigate such attacks, Stripe includes a timestamp in the `Stripe-Signature` header. Because this timestamp is part of the signed payload, it’s also verified by the signature, so an attacker can’t change the timestamp without invalidating the signature. If the signature is valid but the timestamp is too old, you can have your application reject the payload. Our libraries have a default tolerance of 5 minutes between the timestamp and the current time. You can change this tolerance by providing an additional parameter when verifying signatures. Use Network Time Protocol ([NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol)) to make sure that your server’s clock is accurate and synchronizes with the time on Stripe’s servers. > Don’t use a tolerance value of `0`. Using a tolerance value of `0` disables the recency check entirely. Stripe generates the timestamp and signature each time we send an event to your endpoint. If Stripe retries an event (for example, your endpoint previously replied with a non-`2xx` status code), then we generate a new signature and timestamp for the new delivery attempt. ### Quickly return a 2xx response Your [endpoint](https://docs.stripe.com/webhooks.md#example-endpoint) must quickly return a successful status code (`2xx`) prior to any complex logic that could cause a timeout. For example, you must return a `200` response before updating a customer’s invoice as paid in your accounting system. ## See also - [Send events to Amazon EventBridge](https://docs.stripe.com/event-destinations/eventbridge.md) - [List of thin event types](https://docs.stripe.com/api/v2/events/event-types.md) - [List of snapshot event types](https://docs.stripe.com/api/events/.md) - [Interactive webhook endpoint builder](https://docs.stripe.com/webhooks/quickstart.md)",
    "wordCount": 12601,
    "scrapedAt": "2025-10-07T07:15:25.016Z",
    "docType": "api",
    "metadata": {
      "source": "stripe.com",
      "contentType": "text/plain; charset=utf-8"
    }
  },
  {
    "id": "errors_1759821326786",
    "url": "https://stripe.com/docs/error-codes",
    "category": "errors",
    "title": "",
    "content": "# Error codes Learn more about error codes and how to resolve them. Stripe logs every successful or failed API request your integration makes. Use [Workbench](https://dashboard.stripe.com/workbench) to review errors and monitor your integration. Some [Errors](https://docs.stripe.com/api/errors.md) include an [error code](https://docs.stripe.com/api/errors.md#errors-code)—a short string with a brief explanation. These codes can help you [handle errors](https://docs.stripe.com/error-handling.md), such as [payment errors](https://docs.stripe.com/error-handling.md#payment-errors). The following is a list of Stripe error codes, their descriptions, and occasionally information about how to resolve them. Every `Error` object links to this list in its [doc_url](https://docs.stripe.com/api/errors.md#errors-doc_url) attribute. You can also trigger certain [specific error codes](https://docs.stripe.com/testing.md#declined-payments) for testing purposes. | Error code | Description | | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | `account_closed` | The customer’s bank account has been closed. | | `account_country_invalid_address` | The country of the business address provided doesn’t match the country of the account. Businesses must be located in the same country as the account. | | `account_invalid` | The account ID provided as a value for the `Stripe-Account` header is invalid. Check that your requests are specifying a valid account ID. | | `account_error_country_change_requires_additional_steps` | Your account has already onboarded as a Connect platform. Changing your country requires additional steps. Contact Stripe support for more information. | | `account_number_invalid` | The bank account number provided is invalid (for example, missing digits). Bank account information varies from country to country. We recommend creating validations in your entry forms based on the [bank account formats](https://docs.stripe.com/connect/payouts-bank-accounts.md) we provide. | | `amount_too_large` | The specified amount is greater than the maximum amount allowed. Use a lower amount and try again. | | `amount_too_small` | The specified amount is less than the minimum amount allowed. Use a higher amount and try again. | | `api_key_expired` | The API key provided has expired. Obtain your current API keys from the [Dashboard](https://dashboard.stripe.com/apikeys) and update your integration to use them. | | `authentication_required` | The payment requires authentication to proceed. If your customer is [off session](https://docs.stripe.com/api/payment_intents/confirm.md#confirm_payment_intent-off_session), notify your customer to return to your application and complete the payment. If you provided the [error_on_requires_action](https://docs.stripe.com/payments/without-card-authentication.md) parameter, then your customer should try another card that doesn’t require authentication. | | `balance_insufficient` | The transfer or payout couldn’t be completed because the associated account doesn’t have a sufficient balance available. Create a new transfer or payout using an amount less than or equal to the account’s available balance. | | `balance_invalid_parameter` | Invalid parameter was provided in the balance method object. Check our API documentation or the returned error message for more context. | | `bank_account_bad_routing_numbers` | The bank account is known to not support the currency in question. | | `bank_account_declined` | The bank account provided can’t be used to charge, either because it isn’t verified yet or it isn’t supported. | | `bank_account_exists` | The bank account provided already exists on the specified [Customer](https://docs.stripe.com/api.md#update_customer-source) object. If the bank account should also be attached to a different customer, include the correct customer ID when making the request again. | | `bank_account_verification_failed` | The bank account can’t be verified, either because the microdeposit amounts provided don’t match the actual amounts, or because verification has failed too many times. | | `bank_account_unusable` | The bank account provided can’t be used. A different bank account must be used. | | `bank_account_unverified` | Your Connect platform is attempting to share an unverified bank account with a connected account. | | `capture_charge_authorization_expired` | The charge can’t be captured as the authorization has expired. Refer to the payment method’s documentation to learn more. | | `capture_unauthorized_payment` | The charge you’re attempting to capture has not been authorized for capturing payment. | | `card_decline_rate_limit_exceeded` | This card has been declined too many times. You can try to charge this card again after 24 hours. We suggest reaching out to your customer to make sure they’ve entered all of their information correctly and that there are no issues with their card. | | `charge_already_captured` | The charge you’re attempting to capture has already been captured. Update the request with an uncaptured charge ID. | | `charge_already_refunded` | The charge you’re attempting to [refund](https://docs.stripe.com/refunds.md) has already been refunded. Update the request to use the ID of a charge that has not been refunded. | | `charge_disputed` | The charge you’re attempting to [refund](https://docs.stripe.com/refunds.md) has been charged back. See [Disputes](https://docs.stripe.com/disputes.md) to learn how to respond to the dispute. | | `charge_exceeds_source_limit` | This charge would cause you to exceed your rolling-window processing limit for this source type. Retry the charge later, or [contact us](https://support.stripe.com/email) to request a higher processing limit. | | `charge_exceeds_transaction_limit` | This charge would cause you to exceed your processing limit for this payment type. [Contact us](https://support.stripe.com/contact/login) to request a higher processing limit. | | `charge_invalid_parameter` | One or more provided parameters was not allowed for the given operation on the Charge. See our [API reference](https://docs.stripe.com/api/charges.md) or the returned error message to see which values weren’t correct for that Charge. | | `country_unsupported` | Your platform attempted to create a custom account in a country that’s not yet supported. Make sure that users can only sign up in [countries supported by custom accounts](https://docs.stripe.com/connect/custom-accounts.md#country). | | `country_code_invalid` | The country code provided was invalid. | | `coupon_expired` | The [coupon](https://docs.stripe.com/api.md#coupons) provided for a [subscription](https://docs.stripe.com/api.md#subscriptions) or [order](https://docs.stripe.com/api.md#orders) has expired. Either create a new coupon, or use an existing one that’s valid. | | `customer_max_subscriptions` | The maximum number of subscriptions for a customer has been reached. [Contact us](https://support.stripe.com/email) if you’re receiving this error. | | `customer_max_payment_methods` | The maximum number of [PaymentMethods](https://docs.stripe.com/api/payment_methods.md) for this [Customer](https://docs.stripe.com/api/customers.md) has been reached. Either [detach](https://docs.stripe.com/api/payment_methods/detach.md) some PaymentMethods from this Customer or proceed with a different Customer. | | `customer_tax_location_invalid` | The customer address is missing or not valid for tax purposes. Make sure to provide a [country](https://docs.stripe.com/api/customers/object.md#customer_object-address-country) as a two-letter [ISO code](https://en.wikipedia.org/wiki/ISO_3166-1) and also a [postal_code](https://docs.stripe.com/api/customers/object.md#customer_object-address-postal_code), at minimum. See how to [collect customer addresses](https://docs.stripe.com/tax/customer-locations.md). | | `shipping_address_invalid` | The shipping address information can’t be used to accurately determine tax rates. Verify that address fields such as zip code, state, or province have been added correctly. | | `billing_invalid_mandate` | The Subscription or Invoice attempted payment on a PaymentMethod without an active mandate. To create Subscription or Invoice payments with this PaymentMethod, it must be confirmed on-session with a PaymentIntent or SetupIntent first. | | `email_invalid` | The email address is invalid (for example, not properly formatted). Check that the email address is properly formatted and only includes [allowed characters](https://en.wikipedia.org/wiki/Email_address#Local-part). | | `idempotency_key_in_use` | The idempotency key provided is currently being used in another request. This occurs if your integration is making duplicate requests simultaneously. | | `financial_connections_account_inactive` | Data can’t be refreshed on inactive Financial Connections accounts. | | `financial_connections_no_successful_transaction_refresh` | Transaction data can only be retrieved for accounts that have at least one successful transaction refresh. | | `instant_payouts_unsupported` | Instant Payouts are not available for this request. See [Instant payouts](https://support.stripe.com/topics/instant-payouts) for detailed requirements and supported configurations. | | `instant_payouts_limit_exceeded` | You’ve reached your daily processing limits for Instant Payouts. | | `instant_payouts_config_disabled` | This connected account isn’t eligible for Instant Payouts. Ask the platform to enable Instant Payouts. | | `payouts_limit_exceeded` | You’ve reached your daily processing limits for this payout type. | | `insufficient_funds` | The customer’s account has insufficient funds to cover this payment. | | `invalid_characters` | This value provided to the field contains characters that are unsupported by the field. | | `invalid_card_type` | The card provided as an [external account](https://stripe.com/api#external_accounts) isn’t supported for payouts. Provide a non-prepaid debit card instead. | | `invoice_no_customer_line_items` | An invoice can’t be generated for the specified customer as there are no pending invoice items. Verify that the correct customer is being specified or create any necessary invoice items first. | | `invoice_on_behalf_of_not_editable` | You can’t update the `on_behalf_of` property of an invoice after the invoice has been assigned a number. | | `invoice_no_payment_method_types` | An invoice can’t be finalized because there are no payment method types available to process the payment. Your [invoice template settings](https://dashboard.stripe.com/settings/billing/invoice) or the invoice’s [payment_settings](https://docs.stripe.com/api/invoices/object.md#invoice_object-payment_settings) might be restricting which payment methods are available, or you might need to activate more [payment methods](https://dashboard.stripe.com/settings/payments) in the Dashboard. | | `invoice_no_subscription_line_items` | An invoice can’t be generated for the specified subscription as there are no pending invoice items. Verify that the correct subscription is being specified or create any necessary invoice items first. | | `invoice_not_editable` | The specified invoice can no longer be edited. Instead, consider creating additional [invoice items](https://docs.stripe.com/billing/invoices/subscription.md#adding-upcoming-invoice-items) that will be applied to the next invoice. You can either [manually generate](https://docs.stripe.com/billing/invoices/subscription.md#generating-invoices) the next invoice or wait for it to be automatically generated at the end of the billing cycle. | | `invoice_payment_intent_requires_action` | This payment requires additional user action before it can be completed successfully. Payment can be completed using the PaymentIntent associated with the invoice. | | `invoice_upcoming_none` | There is no upcoming invoice on the specified customer to preview. Only customers with active subscriptions or pending invoice items have invoices that can be previewed. | | `no_account` | The bank account couldn’t be located. | | `debit_not_authorized` | The customer has notified their bank that this payment was unauthorized. | | `bank_account_restricted` | The customer’s account can’t be used with the payment method. | | `out_of_inventory` | One or more line item(s) are out of stock. If more stock is available, update the inventory’s orderable quantity and try again. | | `parameter_invalid_empty` | One or more required values weren’t provided. Make sure requests include all required parameters. | | `parameter_invalid_integer` | One or more of the parameters requires an integer, but the values provided were a different type. Make sure that only supported values are provided for each attribute. Refer to the [API reference](https://docs.stripe.com/api.md) to see the type of data each attribute supports. | | `parameter_invalid_string_blank` | One or more values provided only included whitespace. Check the values in your request and update any that contain only whitespace. | | `parameter_invalid_string_empty` | One or more required string values is empty. Make sure that string values contain at least one character. | | `parameter_missing` | One or more required values are missing. Check our [API documentation](https://docs.stripe.com/api.md) to see which values are required to create or modify the specified resource. | | `parameter_unknown` | The request contains one or more unexpected parameters. Remove these and try again. | | `parameters_exclusive` | Two or more mutually exclusive parameters were provided. See the [API reference](https://docs.stripe.com/api.md) or the returned error message to see which values are permitted when creating or modifying the specified resource. | | `acss_debit_session_incomplete` | The ACSS debit session isn’t ready to transition to complete status yet. Try the request again later. | | `payment_method_billing_details_address_missing` | The PaymentMethod’s billing details is missing address details. Update the missing fields and try again. | | `payment_method_unsupported_type` | The API only supports payment methods of certain types. | | `payment_method_customer_decline` | The customer didn’t approve the payment. Provide a new payment method to attempt to fulfill this intent again. | | `payment_method_microdeposit_verification_attempts_exceeded` | You’ve exceeded the number of allowed verification attempts. | | `intent_invalid_state` | Intent isn’t in the state that’s required to perform the operation. | | `intent_verification_method_missing` | Intent doesn’t have verification method specified in its `PaymentMethodOptions` object. | | `payment_method_invalid_parameter` | Invalid parameter was provided in the payment method object. See the [API reference](https://docs.stripe.com/api.md) or the returned error message for more context. | | `payment_method_invalid_parameter_testmode` | The parameter provided for payment method isn’t allowed to be used in testmode. See the [API reference](https://docs.stripe.com/api.md) or the returned error message for more context. | | `payment_method_provider_timeout` | The payment method failed due to a timeout. Check the [last_payment_error](https://docs.stripe.com/api/payment_intents/object.md#payment_intent_object-last_payment_error) or [last_setup_error](https://docs.stripe.com/api/setup_intents/object.md#setup_intent_object-last_setup_error) property on the PaymentIntent or SetupIntent respectively for more details, and provide a new payment method to attempt to fulfill this intent again. | | `payment_method_provider_decline` | The payment or setup attempt was declined by the issuer or customer. Check the [last_payment_error](https://docs.stripe.com/api/payment_intents/object.md#payment_intent_object-last_payment_error) or [last_setup_error](https://docs.stripe.com/api/setup_intents/object.md#setup_intent_object-last_setup_error) property on the PaymentIntent or SetupIntent respectively for more details, and provide a new payment method to attempt to fulfill this intent again. | | `payment_method_microdeposit_verification_amounts_mismatch` | The amounts provided don’t match the amounts that were sent to the bank account. | | `payment_method_microdeposit_verification_descriptor_code_mismatch` | The verification code provided doesn’t match the one sent to the bank account. | | `payment_method_microdeposit_verification_amounts_invalid` | You must provide exactly two microdeposit amounts. | | `payment_method_microdeposit_failed` | Microdeposits were failed to be deposited into the customer’s bank account. Check the account, institution, transit numbers, and currency type. | | `payment_method_microdeposit_verification_timeout` | Payment method should be verified with microdeposits within the required period. | | `payment_method_bank_account_already_verified` | This bank account has already been verified. | | `payment_method_bank_account_blocked` | This bank account has failed verification in the past and can’t be used. [Contact us](https://support.stripe.com/email) if you want to attempt to use these bank account credentials. | | `payment_method_unactivated` | The operation can’t be performed because the payment method used hasn’t been activated. Activate the payment method in the [Dashboard](https://dashboard.stripe.com/account/payments/settings), then try again. | | `payment_method_currency_mismatch` | The currency specified doesn’t match the currency for the attached payment method. A payment can only be created for the same currency as the corresponding payment method. | | `payment_method_unexpected_state` | The provided payment method’s state was incompatible with the operation you were trying to perform. Confirm that the payment method is in an allowed state for the given operation before attempting to perform it. | | `payment_method_not_available` | The payment processor for the provided payment method is temporarily unavailable. Try a different payment method or retry later with the same payment method. | | `payment_intent_unexpected_state` | The PaymentIntent’s state was incompatible with the operation you were trying to perform. | | `payment_intent_incompatible_payment_method` | The PaymentIntent expected a payment method with different properties than what was provided. | | `payment_intent_invalid_parameter` | One or more provided parameters was not allowed for the given operation on the PaymentIntent. See the [API reference](https://docs.stripe.com/api/payment_intents.md) or the returned error message to see which values weren’t correct for that PaymentIntent. | | `payment_intent_mandate_invalid` | The provided mandate is invalid and can’t be used for the payment intent. | | `setup_intent_mandate_invalid` | The provided mandate is invalid and can’t be used for the setup intent. | | `invalid_mandate_reference_prefix_format` | The provided prefix used to generate the mandate reference is invalid. | | `payment_intent_konbini_rejected_confirmation_number` | The `confirmation_number` provided in `payment_method_options[konbini]` was rejected by the processing partner at time of PaymentIntent confirmation. | | `payment_intent_authentication_failure` | The provided payment method has failed authentication. Provide a new payment method to attempt to fulfill this PaymentIntent again. | | `payment_intent_payment_attempt_failed` | The latest payment attempt for the PaymentIntent has failed. See the [last_payment_error](https://docs.stripe.com/api/payment_intents/object.md#payment_intent_object-last_payment_error) property on the PaymentIntent for more details, and provide a new payment method to attempt to fulfill this PaymentIntent again. | | `payment_intent_payment_attempt_expired` | The latest payment attempt for the PaymentIntent has expired. Check the [last_payment_error](https://docs.stripe.com/api/payment_intents/object.md#payment_intent_object-last_payment_error) property on the PaymentIntent for more details, and provide a new payment method to attempt to fulfill this PaymentIntent again. | | `setup_intent_setup_attempt_expired` | The latest setup attempt for the SetupIntent has expired. Check the [last_setup_error](https://docs.stripe.com/api/setup_intents/object.md#setup_intent_object-last_setup_error) property on the SetupIntent for more details, and provide a new payment method to attempt to complete this SetupIntent again. | | `payment_intent_amount_reconfirmation_required` | You provided information that changed the total amount of your PaymentIntent. Show the updated amount to your customer and try again. | | `payment_intent_automatic_tax_incomplete` | When `automatic_tax[enabled]=true`, you must provide enough location information to accurately determine tax rates for the buyer to confirm the PaymentIntent and collect taxes. | | `payment_intent_action_required` | The provided payment method requires customer actions to complete, but `error_on_requires_action` was set. To add this payment method to your integration, we recommend that you first [upgrade your integration to handle actions](https://docs.stripe.com/payments/payment-intents/upgrade-to-handle-actions.md). | | `platform_account_required` | Only Stripe Connect platforms can work with other accounts. You can set up a Stripe Connect platform in the [Dashboard](https://dashboard.stripe.com/account/applications/settings). | | `setup_intent_authentication_failure` | The provided payment method has failed authentication. Provide a new payment method to attempt to fulfill this SetupIntent again. | | `setup_intent_unexpected_state` | The SetupIntent’s state was incompatible with the operation you were trying to perform. | | `setup_intent_invalid_parameter` | One or more provided parameters was not allowed for the given operation on the SetupIntent. See the [API reference](https://docs.stripe.com/api/setup_intents.md) or the returned error message to see which values weren’t correct for that SetupIntent. | | `setup_attempt_failed` | The latest setup attempt for the SetupIntent has failed. Check the `last_setup_error` property on the SetupIntent for more details, and provide a new payment method to attempt to set it up again. | | `status_transition_invalid` | The requested status transition isn’t valid. | | `payouts_not_allowed` | Payouts have been disabled on the connected account. Check the connected account’s status to see if any [additional information](https://docs.stripe.com/connect/identity-verification.md) needs to be provided, or if payouts have been disabled for [another reason](https://docs.stripe.com/connect/handling-api-verification.md). | | `platform_api_key_expired` | The API key provided by your Connect platform has expired. This occurs if your platform has either generated a new key or the connected account has been disconnected from the platform. Obtain your current API keys from the [Dashboard](https://dashboard.stripe.com/account/apikeys) and update your integration, or contact the user and reconnect the account. | | `postal_code_invalid` | The postal code provided was incorrect. | | `refer_to_customer` | The customer has stopped the payment with their bank. Contact them for details and to arrange payment. | | `resource_already_exists` | A resource with a user-specified ID (for example, plan or coupon) already exists. Use a different, unique value for `id` and try again. | | `resource_missing` | The ID provided isn’t valid. Either the resource doesn’t exist, or an ID for a different resource has been provided. | | `routing_number_invalid` | The bank routing number provided is invalid. | | `stripe_tax_inactive` | Stripe Tax hasn’t been activated on your account. See the [setup documentation](https://docs.stripe.com/tax/set-up.md) to get started. | | `clearing_code_unsupported` | The clearing code provided isn’t supported. | | `secret_key_required` | The API key provided is a publishable key, but a secret key is required. Obtain your current API keys from the [Dashboard](https://dashboard.stripe.com/account/apikeys) and update your integration to use them. | | `state_unsupported` | Occurs when providing the `legal_entity` information for a U.S. custom account, if the provided state isn’t supported. (This is mostly associated states and territories.) | | `tax_id_invalid` | The tax ID number provided is invalid (for example, missing digits). Tax ID information varies from country to country, but must be at least nine digits. | | `tax_id_prohibited` | A tax identifier may not be provided on this payment method as it isn’t required. | | `terminal_location_country_unsupported` | Terminal is currently only available in some countries. Locations in your country can’t be created in live mode. | | `terminal_reader_offline` | Reader is currently offline. Ensure the reader is powered on and connected to the internet before retrying your request. See the [integration guide](https://docs.stripe.com/terminal/payments/collect-card-payment.md?terminal-sdk-platform=server-driven#handle-errors) for details on how to handle this error. | | `terminal_reader_timeout` | There was a timeout when sending this command to the reader. See the [integration guide](https://docs.stripe.com/terminal/payments/collect-card-payment.md?terminal-sdk-platform=server-driven#handle-errors) for details on how to handle this error. | | `terminal_reader_busy` | Reader is currently busy processing another request. See the [integration guide](https://docs.stripe.com/terminal/payments/collect-card-payment.md?terminal-sdk-platform=server-driven#handle-errors) for details on how to handle this error. | | `terminal_reader_hardware_fault` | Reader can no longer accept payments as an unrecoverable hardware fault has been detected. Contact [Stripe support](https://support.stripe.com/contact/email) and provide your reader’s serial number for replacement. | | `terminal_reader_invalid_location_for_activation` | Reader can’t be activated in the currently registered Location. Register the reader to a new Location. See [Manage locations](https://stripe.com/terminal/fleet/locations) for more information. | | `terminal_reader_invalid_location_for_payment` | Reader can’t take payments in the currently registered Location. Register the reader to a new Location. See [Manage locations](https://stripe.com/terminal/fleet/locations) for more information. | | `tls_version_unsupported` | Your integration is using an older version of [TLS](https://docs.stripe.com/security.md) that’s unsupported. You must be using TLS `1.2` or above. | | `token_already_used` | The token provided has already been used. You must create a new token before you can retry this request. | | `token_in_use` | The token provided is currently being used in another request. This occurs if your integration is making duplicate requests simultaneously. | | `transfers_not_allowed` | The requested transfer can’t be created. [Contact us](https://support.stripe.com/email) if you’re receiving this error. | | `transfer_source_balance_parameters_mismatch` | When creating a Transfer, the `payments` parameter in `source_balance` shouldn’t be passed in when balance `type` is set to `issuing`. | | `url_invalid` | The URL provided is invalid. | | `not_allowed_on_standard_account` | Transfers and payouts on behalf of a Standard connected account aren’t allowed. | | `lock_timeout` | This object can’t be accessed right now because another API request or Stripe process is currently accessing it. If you see this error intermittently, retry the request. If you see this error frequently and are making multiple concurrent requests to a single object, make your requests serially or at a lower rate. See the [Object lock timeouts](https://docs.stripe.com/rate-limits.md#object-lock-timeouts) for more details. | | `cardholder_phone_number_required` | You must have a `phone_number` on file for Issuing Cardholders who will be creating EU cards. You can’t create EU cards without a `phone_number` on file for the cardholder. See the [3DS Secure](https://docs.stripe.com/issuing/3d-secure.md) for more details. | | `return_intent_already_processed` | You can’t confirm this refund as it’s already processed. | | `refund_disputed_payment` | You can’t refund a disputed payment. | | `progressive_onboarding_limit_exceeded` | Progressive onboarding limit has been reached for the platform. | | `forwarding_api_inactive` | The Vault and Forward API is currently not accessible with this account and configuration. [Contact us](https://support.stripe.com/contact) if you’re receiving this error. | | `forwarding_api_invalid_parameter` | Invalid parameter was provided in the Vault and Forward API. Check our API documentation or the returned error message for more context. | | `forwarding_api_upstream_connection_timeout` | The request to the destination endpoint timed out. This typically indicates a problem with the destination endpoint, rather than with Stripe. | | `forwarding_api_upstream_connection_error` | Stripe didn’t receive a response from the destination endpoint. This typically indicates a problem with the destination endpoint, rather than with Stripe. | | `forwarding_api_retryable_upstream_error` | The destination endpoint appears to be offline or unresponsive, preventing Stripe from completing the request. Retry the request later. | | `forwarding_api_upstream_error` | The destination endpoint appears to be offline or unresponsive, preventing Stripe from completing the request. You might want to investigate the state of the request on the third party because bytes might have been sent and the third-party state could be indeterminate. | | `alipay_upgrade_required` | This method for creating Alipay payments isn’t supported anymore. Upgrade your integration to use [Sources](https://docs.stripe.com/sources/alipay.md) instead. | | `bitcoin_upgrade_required` | This method for creating Bitcoin payments isn’t supported anymore. Upgrade your integration to use [Sources](https://docs.stripe.com/sources.md) instead. | | `card_declined` | The card has been declined. When a card is declined, the error returned also includes the `decline_code` attribute with the reason why the card was declined. To learn more, see [decline codes](https://docs.stripe.com/declines/codes.md). | | `charge_expired_for_capture` | The charge can’t be captured because the authorization has expired. Authorization and capture charges must be captured within a set number of days (7 by default). | | `expired_card` | The card has expired. Check the expiration date or use a different card. | | `incorrect_address` | The card’s address is incorrect. Check the card’s address or use a different card. | | `incorrect_cvc` | The card’s security code is incorrect. Check the card’s security code or use a different card. | | `incorrect_number` | The card number is incorrect. Check the card’s number or use a different card. | | `incorrect_zip` | The card’s postal code is incorrect. Check the card’s postal code or use a different card. | | `invalid_tax_location` | The specified location is invalid. Check the [Supported address formats](https://docs.stripe.com/tax/customer-locations.md#supported-formats) for the address formats supported when calculating tax. | | `invalid_charge_amount` | The specified amount is invalid. The charge amount must be a positive integer in the smallest currency unit, and not exceed the [minimum or maximum amount](https://docs.stripe.com/currencies.md#minimum-and-maximum-charge-amounts). | | `invalid_cvc` | The card’s security code is invalid. Check the card’s security code or use a different card. | | `invalid_expiry_month` | The card’s expiration month is incorrect. Check the expiration date or use a different card. | | `invalid_expiry_year` | The card’s expiration year is incorrect. Check the expiration date or use a different card. | | `invalid_number` | The card number is invalid. Check the card details or use a different card. | | `invalid_source_usage` | The source can’t be used because it isn’t in the correct state (for example, a charge request is trying to use a source with a `pending`, `failed`, or `consumed` status). Check the [status](https://docs.stripe.com/api.md#source_object-status) of the source you’re attempting to use. | | `livemode_mismatch` | Test and live mode API keys, requests, and objects are only available within the corresponding mode. | | `missing` | Both a customer and source ID have been provided, but the source hasn’t been saved to the customer. To create a charge for a customer with a specified source, you must first save the card details. | | `processing_error` | An error occurred while processing the card. Try again later or with a different payment method. | | `product_inactive` | The product this SKU belongs to is no longer available for purchase. | | `rate_limit` | Too many requests hit the API too quickly. We recommend an exponential backoff of your requests. | | `sepa_unsupported_account` | Your account doesn’t support [SEPA](https://docs.stripe.com/sources/sepa-debit.md) payments. | | `shipping_calculation_failed` | Shipping calculation failed because the information provided was either incorrect or couldn’t be verified. | | `sku_inactive` | The SKU is inactive and no longer available for purchase. Use a different SKU, or make the current SKU active again. | | `taxes_calculation_failed` | Tax calculation for the order failed. | | `testmode_charges_only` | Your account hasn’t been activated and can only make test charges. [Activate your account](https://dashboard.stripe.com/account/onboarding) in the Dashboard to begin processing live charges. |",
    "wordCount": 4291,
    "scrapedAt": "2025-10-07T07:15:26.786Z",
    "docType": "api",
    "metadata": {
      "source": "stripe.com",
      "contentType": "text/plain; charset=utf-8"
    }
  },
  {
    "id": "payments_1759821328605",
    "url": "https://stripe.com/docs/payments/payment-methods",
    "category": "payments",
    "title": "",
    "content": "# Payment Methods API Learn more about the API that powers a range of global payment methods. The Payment Methods API allows you to accept a variety of payment methods through a single API. A [PaymentMethod](https://docs.stripe.com/api/payment_methods/object.md) object contains the payment method details to create payments. With the Payment Methods API, you can combine a *PaymentMethod* (PaymentMethods represent your customer's payment instruments, used with the Payment Intents or Setup Intents APIs): - With a [PaymentIntent](https://docs.stripe.com/api/payment_intents.md) to accept a payment - With a [SetupIntent](https://docs.stripe.com/api/setup_intents.md) and a *Customer* (Customer objects represent customers of your business. They let you reuse payment methods and give you the ability to track multiple payments) to save payment details for later ## Supported payment methods To determine which payment methods to use for specific locales, see the [guide to payment methods](https://stripe.com/payments/payment-methods-guide). The guide includes available payment methods for different regions, a detailed description of each payment method’s characteristics, and the [geographic regions](https://stripe.com/payments/payment-methods-guide#payment-methods-fact-sheets) where they’re most relevant. You can enable any payment methods available to you in the [Dashboard](https://dashboard.stripe.com). Activation is generally instantaneous and doesn’t require additional contracts. ## Customer actions ​​Some payment methods require your customer to take additional steps to complete the payment. The PaymentIntent object’s `next_action` parameter specifies the type of customer action. Some common actions that customers need to perform are: - ​​Redirect to their bank’s online service to authenticate and approve the payment. - Verify ownership of their account by providing a one-time code that you post to the Stripe API (for example, microdeposits). - Push funds (for example, in the case for bank transfers) through their bank’s online service. Not all payment methods require additional customer actions. For example, card payments (excluding 3D Secure) require no additional authentication beyond collecting card details. > For payment methods that require customer action, configure [webhook endpoints](https://docs.stripe.com/payments/payment-methods.md#webhooks) for notifications on whether a payment has succeeded or not. ## Immediate or delayed notification of payment success Some payment methods immediately return payment status when a transaction is attempted (for example, card payments) but other methods have a delay such as ACH debits. For those that immediately return payment status, the PaymentIntent status either changes to `succeeded` or `requires_payment_method`. A status of `succeeded` guarantees that you will receive the funds from your customers. Payment methods with delayed notification can’t guarantee payment during the delay. The status of the PaymentIntent object will be `processing` until the payment status is either successful or failed. It’s common for businesses to hold an order in a *pending* state during this time, not fulfilling the order until the payment is successful. > ​​For payment methods with delayed notification, configure [webhook endpoints](https://docs.stripe.com/payments/payment-methods.md#webhooks) for notifications on whether a payment has succeeded or not. ## Single-use or reusable You can reuse certain payment methods (for example, cards or bank debits) for additional payments without authorizing and collecting payment details again. You should always set up reusable payment methods for future use to reduce the chance of future declines and payment friction (such as [authentication being required](https://docs.stripe.com/strong-customer-authentication.md)). Reusable payment methods can be [set up for future use when accepting a payment](https://docs.stripe.com/payments/save-during-payment.md) or [set up for future use without taking a payment](https://docs.stripe.com/payments/save-and-reuse.md). Single-use payment methods (for example, some kinds of bank transfers) can’t be attached to customers because they’re consumed after a payment attempt. ## Use webhooks to track payment status Configure webhooks by creating a [webhook endpoint or other type of event destination](https://docs.stripe.com/event-destinations.md) for payment methods that either require customer action or when payment notification is delayed. Stripe sends the following events when the `PaymentIntent` status is updated: | Event | Description | Next steps | | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------- | | `payment_intent.processing` | The customer’s payment was submitted to Stripe successfully. Only applicable to payment methods with [delayed notification](https://docs.stripe.com/payments/payment-methods.md#payment-notification). | Wait for the initiated payment to succeed or fail. | | `payment_intent.succeeded` | The payment succeeded. | Fulfill the purchased goods or services. | | `payment_intent.payment_failed` | The payment failed. | Send an email or push notification to request another payment method. | ​​You can also use the following options instead of setting up an event destination to listen to events: - Manually track the status of payments in the Stripe Dashboard, if your business accepts a low volume of orders from payment methods with delayed notification. The Dashboard allows you to [view all your Stripe payments](https://dashboard.stripe.com/test/payments), send email receipts, handle payouts, or retry failed payments. - Use polling (for example, repeatedly retrieving a PaymentIntent so that you can check its status). Note that polling is significantly less reliable and may not work at scale. Stripe enforces rate limiting on API requests, so exercise caution if you use polling. - Use a partner application to handle common business events, like [automation](https://stripe.partners/?f_category=automation) or [marketing and sales](https://stripe.partners/?f_category=marketing-and-sales), by integrating a partner application. ## The PaymentMethod object A PaymentMethod contains reusable payment method details for creating payments (for example, card expiration date or billing address), it doesn’t include transaction-specific information (for example, amount, currency). A PaymentMethod is attached to a PaymentIntent to represent the [states of a payment lifecycle](https://docs.stripe.com/payments/paymentintents/lifecycle.md). Each PaymentMethod has a [type attribute](https://docs.stripe.com/api/payment_methods/object.md#payment_method_object-type) (for example, `\"type\": \"sepa_debit\"` ) and an additional hash whose name matches the type and contains information specific to the PaymentMethod type (for example, `\"sepa_debit\":{}`). Example of a `sepa_debit` PaymentMethod object: ```json { \"id\": \"pm_123456789\", \"object\": \"payment_method\", \"billing_details\": { \"address\": {...}, \"email\": \"jenny@example.com\", \"name\": \"Jenny Rosen\", \"phone\": \"+335555555555\" },\"sepa_debit\": { \"bank_code\": \"37040044\", \"branch_code\": \"94832\", \"country\": \"FR\", \"fingerprint\": \"ygEJfUjzWMGyWnZg\", \"last4\": \"3000\" }, \"type\": \"sepa_debit\", (...) } ``` > To safely handle sensitive payment information and automatically handle customer actions, Stripe recommends that you create payment methods using [Stripe.js](https://docs.stripe.com/js.md#stripe-create-payment-method). ## See also - [Guide to Payment Methods](https://stripe.com/payments/payment-methods-guide) - [Payment Methods API reference](https://docs.stripe.com/api/payment_methods.md)",
    "wordCount": 947,
    "scrapedAt": "2025-10-07T07:15:28.605Z",
    "docType": "api",
    "metadata": {
      "source": "stripe.com",
      "contentType": "text/plain; charset=utf-8"
    }
  }
]